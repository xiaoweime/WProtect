<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Crypto++: validat2.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>validat2.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// validat2.cpp - written and placed in the public domain by Wei Dai</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &quot;pch.h&quot;</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#include &quot;blumshub.h&quot;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;<a class="code" href="rsa_8h.html" title="This file contains classes that implement the RSA ciphers and signature schemes as defined in PKCS #1...">rsa.h</a>&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;md2.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;elgamal.h&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;nr.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="dsa_8h.html">dsa.h</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="dh_8h.html">dh.h</a>&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;<a class="code" href="mqv_8h.html">mqv.h</a>&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;<a class="code" href="luc_8h.html">luc.h</a>&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;<a class="code" href="xtrcrypt_8h.html" title="&amp;quot;The XTR public key system&amp;quot; by Arjen K.">xtrcrypt.h</a>&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;<a class="code" href="rabin_8h.html">rabin.h</a>&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="rw_8h.html" title="This file contains classes that implement the Rabin-Williams signature schemes as defined in IEEE P13...">rw.h</a>&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="eccrypto_8h.html">eccrypto.h</a>&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;ecp.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;ec2n.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;asn.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;rng.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;files.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;hex.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;oids.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="esign_8h.html" title="This file contains classes that implement the ESIGN signature schemes as defined in IEEE P1363a...">esign.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="osrng_8h.html">osrng.h</a>&quot;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;validate.h&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 USING_NAMESPACE(CryptoPP)
<a name="l00035"></a>00035 USING_NAMESPACE(std)
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="class_fixed_r_n_g.html">00037</a> class <a class="code" href="class_fixed_r_n_g.html">FixedRNG</a> : public <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a>
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039 <span class="keyword">public</span>:
<a name="l00040"></a>00040         <a class="code" href="class_fixed_r_n_g.html">FixedRNG</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;source) : m_source(source) {}
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="class_fixed_r_n_g.html#a93c800795dea0f52681dc6d4d7f254eb">00042</a>         <span class="keywordtype">void</span> GenerateBlock(byte *output, <span class="keywordtype">size_t</span> size)
<a name="l00043"></a>00043         {
<a name="l00044"></a>00044                 m_source.Get(output, size);
<a name="l00045"></a>00045         }
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keyword">private</span>:
<a name="l00048"></a>00048         <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;m_source;
<a name="l00049"></a>00049 };
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keywordtype">bool</span> ValidateBBS()
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053         cout &lt;&lt; <span class="stringliteral">&quot;\nBlumBlumShub validation suite running...\n\n&quot;</span>;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> p(<span class="stringliteral">&quot;212004934506826557583707108431463840565872545889679278744389317666981496005411448865750399674653351&quot;</span>);
<a name="l00056"></a>00056         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> q(<span class="stringliteral">&quot;100677295735404212434355574418077394581488455772477016953458064183204108039226017738610663984508231&quot;</span>);
<a name="l00057"></a>00057         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> seed(<span class="stringliteral">&quot;63239752671357255800299643604761065219897634268887145610573595874544114193025997412441121667211431&quot;</span>);
<a name="l00058"></a>00058         <a class="code" href="class_blum_blum_shub.html" title="BlumBlumShub with factorization of the modulus.">BlumBlumShub</a> bbs(p, q, seed);
<a name="l00059"></a>00059         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00060"></a>00060         <span class="keywordtype">int</span> j;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062         <span class="keyword">const</span> byte output1[] = {
<a name="l00063"></a>00063                 0x49,0xEA,0x2C,0xFD,0xB0,0x10,0x64,0xA0,0xBB,0xB9,
<a name="l00064"></a>00064                 0x2A,0xF1,0x01,0xDA,0xC1,0x8A,0x94,0xF7,0xB7,0xCE};
<a name="l00065"></a>00065         <span class="keyword">const</span> byte output2[] = {
<a name="l00066"></a>00066                 0x74,0x45,0x48,0xAE,0xAC,0xB7,0x0E,0xDF,0xAF,0xD7,
<a name="l00067"></a>00067                 0xD5,0x0E,0x8E,0x29,0x83,0x75,0x6B,0x27,0x46,0xA1};
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         byte buf[20];
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         bbs.GenerateBlock(buf, 20);
<a name="l00072"></a>00072         fail = memcmp(output1, buf, 20) != 0;
<a name="l00073"></a>00073         pass = pass &amp;&amp; !fail;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00076"></a>00076         <span class="keywordflow">for</span> (j=0;j&lt;20;j++)
<a name="l00077"></a>00077                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)buf[j];
<a name="l00078"></a>00078         cout &lt;&lt; endl;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080         bbs.Seek(10);
<a name="l00081"></a>00081         bbs.GenerateBlock(buf, 10);
<a name="l00082"></a>00082         fail = memcmp(output1+10, buf, 10) != 0;
<a name="l00083"></a>00083         pass = pass &amp;&amp; !fail;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00086"></a>00086         <span class="keywordflow">for</span> (j=0;j&lt;10;j++)
<a name="l00087"></a>00087                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)buf[j];
<a name="l00088"></a>00088         cout &lt;&lt; endl;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090         bbs.Seek(1234567);
<a name="l00091"></a>00091         bbs.GenerateBlock(buf, 20);
<a name="l00092"></a>00092         fail = memcmp(output2, buf, 20) != 0;
<a name="l00093"></a>00093         pass = pass &amp;&amp; !fail;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00096"></a>00096         <span class="keywordflow">for</span> (j=0;j&lt;20;j++)
<a name="l00097"></a>00097                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)buf[j];
<a name="l00098"></a>00098         cout &lt;&lt; endl;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         <span class="keywordflow">return</span> pass;
<a name="l00101"></a>00101 }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keywordtype">bool</span> SignatureValidate(<a class="code" href="class_p_k___signer.html" title="interface for public-key signers">PK_Signer</a> &amp;priv, <a class="code" href="class_p_k___verifier.html" title="interface for public-key signature verifiers">PK_Verifier</a> &amp;pub, <span class="keywordtype">bool</span> thorough = <span class="keyword">false</span>)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         fail = !pub.<a class="code" href="class_public_key_algorithm.html#aadbb6acca8905a61d75f1951d53a90e5" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#aaa7d67d0c12712de0e33713c73f5b718" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2) || !priv.<a class="code" href="class_private_key_algorithm.html#a0199217f43af73a6ad78fe1303903fe3" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#aaa7d67d0c12712de0e33713c73f5b718" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2);
<a name="l00108"></a>00108         pass = pass &amp;&amp; !fail;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00111"></a>00111         cout &lt;&lt; <span class="stringliteral">&quot;signature key validation\n&quot;</span>;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="keyword">const</span> byte *message = (byte *)<span class="stringliteral">&quot;test message&quot;</span>;
<a name="l00114"></a>00114         <span class="keyword">const</span> <span class="keywordtype">int</span> messageLen = 12;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116         <a class="code" href="class_sec_block.html">SecByteBlock</a> signature(priv.<a class="code" href="class_p_k___signature_scheme.html#af04668d211a923ba03f2721c220272e9" title="maximum signature length produced for a given length of recoverable message part">MaxSignatureLength</a>());
<a name="l00117"></a>00117         <span class="keywordtype">size_t</span> signatureLength = priv.<a class="code" href="class_p_k___signer.html#a08920dfd51f5d0d8e5f77c8f20b56ce2" title="sign a message">SignMessage</a>(GlobalRNG(), message, messageLen, signature);
<a name="l00118"></a>00118         fail = !pub.<a class="code" href="class_p_k___verifier.html#a4640a967fd291f8be86c1b721dc73b2d" title="check whether input signature is a valid signature for input message">VerifyMessage</a>(message, messageLen, signature, signatureLength);
<a name="l00119"></a>00119         pass = pass &amp;&amp; !fail;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00122"></a>00122         cout &lt;&lt; <span class="stringliteral">&quot;signature and verification\n&quot;</span>;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         ++signature[0];
<a name="l00125"></a>00125         fail = pub.<a class="code" href="class_p_k___verifier.html#a4640a967fd291f8be86c1b721dc73b2d" title="check whether input signature is a valid signature for input message">VerifyMessage</a>(message, messageLen, signature, signatureLength);
<a name="l00126"></a>00126         pass = pass &amp;&amp; !fail;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00129"></a>00129         cout &lt;&lt; <span class="stringliteral">&quot;checking invalid signature&quot;</span> &lt;&lt; endl;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         <span class="keywordflow">if</span> (priv.<a class="code" href="class_p_k___signature_scheme.html#a1f6a62ce468f172636f117ee0693038f" title="length of longest message that can be recovered, or 0 if this signature scheme does not support messa...">MaxRecoverableLength</a>() &gt; 0)
<a name="l00132"></a>00132         {
<a name="l00133"></a>00133                 signatureLength = priv.<a class="code" href="class_p_k___signer.html#a76eb862d0cb8d80e0bee7ad52a0da707" title="sign a recoverable message">SignMessageWithRecovery</a>(GlobalRNG(), message, messageLen, NULL, 0, signature);
<a name="l00134"></a>00134                 <a class="code" href="class_sec_block.html">SecByteBlock</a> recovered(priv.<a class="code" href="class_p_k___signature_scheme.html#a2f2a599ba385e63766d4a7f7ccf2a884" title="length of longest message that can be recovered from a signature of given length, or 0 if this signat...">MaxRecoverableLengthFromSignatureLength</a>(signatureLength));
<a name="l00135"></a>00135                 <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> result = pub.<a class="code" href="class_p_k___verifier.html#a95dff7c35894d953b54d09d1973787da" title="recover a message from its signature">RecoverMessage</a>(recovered, NULL, 0, signature, signatureLength);
<a name="l00136"></a>00136                 fail = !(result.isValidCoding &amp;&amp; result.messageLength == messageLen &amp;&amp; memcmp(recovered, message, messageLen) == 0);
<a name="l00137"></a>00137                 pass = pass &amp;&amp; !fail;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00140"></a>00140                 cout &lt;&lt; <span class="stringliteral">&quot;signature and verification with recovery&quot;</span> &lt;&lt; endl;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142                 ++signature[0];
<a name="l00143"></a>00143                 result = pub.<a class="code" href="class_p_k___verifier.html#a95dff7c35894d953b54d09d1973787da" title="recover a message from its signature">RecoverMessage</a>(recovered, NULL, 0, signature, signatureLength);
<a name="l00144"></a>00144                 fail = result.isValidCoding;
<a name="l00145"></a>00145                 pass = pass &amp;&amp; !fail;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00148"></a>00148                 cout &lt;&lt; <span class="stringliteral">&quot;recovery with invalid signature&quot;</span> &lt;&lt; endl;
<a name="l00149"></a>00149         }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         <span class="keywordflow">return</span> pass;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keywordtype">bool</span> CryptoSystemValidate(<a class="code" href="class_p_k___decryptor.html" title="interface for public-key decryptors">PK_Decryptor</a> &amp;priv, <a class="code" href="class_p_k___encryptor.html" title="interface for public-key encryptors">PK_Encryptor</a> &amp;pub, <span class="keywordtype">bool</span> thorough = <span class="keyword">false</span>)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         fail = !pub.<a class="code" href="class_public_key_algorithm.html#aadbb6acca8905a61d75f1951d53a90e5" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#aaa7d67d0c12712de0e33713c73f5b718" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2) || !priv.<a class="code" href="class_private_key_algorithm.html#a0199217f43af73a6ad78fe1303903fe3" title="returns a const reference to the crypto material used by this object">GetMaterial</a>().<a class="code" href="class_crypto_material.html#aaa7d67d0c12712de0e33713c73f5b718" title="check this object for errors">Validate</a>(GlobalRNG(), thorough ? 3 : 2);
<a name="l00159"></a>00159         pass = pass &amp;&amp; !fail;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00162"></a>00162         cout &lt;&lt; <span class="stringliteral">&quot;cryptosystem key validation\n&quot;</span>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <span class="keyword">const</span> byte *message = (byte *)<span class="stringliteral">&quot;test message&quot;</span>;
<a name="l00165"></a>00165         <span class="keyword">const</span> <span class="keywordtype">int</span> messageLen = 12;
<a name="l00166"></a>00166         <a class="code" href="class_sec_block.html">SecByteBlock</a> ciphertext(priv.<a class="code" href="class_p_k___crypto_system.html#abf04a4e08fb69a1a118bad3e998ef6a6" title="calculate length of ciphertext given length of plaintext">CiphertextLength</a>(messageLen));
<a name="l00167"></a>00167         <a class="code" href="class_sec_block.html">SecByteBlock</a> plaintext(priv.<a class="code" href="class_p_k___crypto_system.html#aa4a3552c933a36b3aea26f31d00bee9b" title="maximum length of plaintext for a given ciphertext length">MaxPlaintextLength</a>(ciphertext.size()));
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         pub.<a class="code" href="class_p_k___encryptor.html#aecb519bc1cb0b261698be999bb5c8961" title="encrypt a byte string">Encrypt</a>(GlobalRNG(), message, messageLen, ciphertext);
<a name="l00170"></a>00170         fail = priv.<a class="code" href="class_p_k___decryptor.html#ab7466675ed050c440c16508f8a88cac1" title="decrypt a byte string, and return the length of plaintext">Decrypt</a>(GlobalRNG(), ciphertext, priv.<a class="code" href="class_p_k___crypto_system.html#abf04a4e08fb69a1a118bad3e998ef6a6" title="calculate length of ciphertext given length of plaintext">CiphertextLength</a>(messageLen), plaintext) != <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a>(messageLen);
<a name="l00171"></a>00171         fail = fail || memcmp(message, plaintext, messageLen);
<a name="l00172"></a>00172         pass = pass &amp;&amp; !fail;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00175"></a>00175         cout &lt;&lt; <span class="stringliteral">&quot;encryption and decryption\n&quot;</span>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <span class="keywordflow">return</span> pass;
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="keywordtype">bool</span> SimpleKeyAgreementValidate(<a class="code" href="class_simple_key_agreement_domain.html" title="interface for domains of simple key agreement protocols">SimpleKeyAgreementDomain</a> &amp;d)
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182         <span class="keywordflow">if</span> (d.GetCryptoParameters().<a class="code" href="class_crypto_material.html#aaa7d67d0c12712de0e33713c73f5b718" title="check this object for errors">Validate</a>(GlobalRNG(), 3))
<a name="l00183"></a>00183                 cout &lt;&lt; <span class="stringliteral">&quot;passed    simple key agreement domain parameters validation&quot;</span> &lt;&lt; endl;
<a name="l00184"></a>00184         <span class="keywordflow">else</span>
<a name="l00185"></a>00185         {
<a name="l00186"></a>00186                 cout &lt;&lt; <span class="stringliteral">&quot;FAILED    simple key agreement domain parameters invalid&quot;</span> &lt;&lt; endl;
<a name="l00187"></a>00187                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         <a class="code" href="class_sec_block.html">SecByteBlock</a> priv1(d.<a class="code" href="class_simple_key_agreement_domain.html#a8e2e4c5ab6584e4aef0c6da6b122a668" title="return length of private keys in this domain">PrivateKeyLength</a>()), priv2(d.<a class="code" href="class_simple_key_agreement_domain.html#a8e2e4c5ab6584e4aef0c6da6b122a668" title="return length of private keys in this domain">PrivateKeyLength</a>());
<a name="l00191"></a>00191         <a class="code" href="class_sec_block.html">SecByteBlock</a> pub1(d.<a class="code" href="class_simple_key_agreement_domain.html#a717ec0ad52950f8d792466ad591b5104" title="return length of public keys in this domain">PublicKeyLength</a>()), pub2(d.<a class="code" href="class_simple_key_agreement_domain.html#a717ec0ad52950f8d792466ad591b5104" title="return length of public keys in this domain">PublicKeyLength</a>());
<a name="l00192"></a>00192         <a class="code" href="class_sec_block.html">SecByteBlock</a> val1(d.<a class="code" href="class_simple_key_agreement_domain.html#aedb873e4aa6fc15ac5245b7af04e4946" title="return length of agreed value produced">AgreedValueLength</a>()), val2(d.<a class="code" href="class_simple_key_agreement_domain.html#aedb873e4aa6fc15ac5245b7af04e4946" title="return length of agreed value produced">AgreedValueLength</a>());
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         d.<a class="code" href="class_simple_key_agreement_domain.html#a75629cd8157dca667c6aff0562ca59af" title="generate private/public key pair">GenerateKeyPair</a>(GlobalRNG(), priv1, pub1);
<a name="l00195"></a>00195         d.<a class="code" href="class_simple_key_agreement_domain.html#a75629cd8157dca667c6aff0562ca59af" title="generate private/public key pair">GenerateKeyPair</a>(GlobalRNG(), priv2, pub2);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         memset(val1.begin(), 0x10, val1.size());
<a name="l00198"></a>00198         memset(val2.begin(), 0x11, val2.size());
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="keywordflow">if</span> (!(d.<a class="code" href="class_simple_key_agreement_domain.html#a732339ca730408cca7b1191fc32eb39e" title="derive agreed value from your private key and couterparty&amp;#39;s public key, return false in case of f...">Agree</a>(val1, priv1, pub2) &amp;&amp; d.<a class="code" href="class_simple_key_agreement_domain.html#a732339ca730408cca7b1191fc32eb39e" title="derive agreed value from your private key and couterparty&amp;#39;s public key, return false in case of f...">Agree</a>(val2, priv2, pub1)))
<a name="l00201"></a>00201         {
<a name="l00202"></a>00202                 cout &lt;&lt; <span class="stringliteral">&quot;FAILED    simple key agreement failed&quot;</span> &lt;&lt; endl;
<a name="l00203"></a>00203                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (memcmp(val1.begin(), val2.begin(), d.<a class="code" href="class_simple_key_agreement_domain.html#aedb873e4aa6fc15ac5245b7af04e4946" title="return length of agreed value produced">AgreedValueLength</a>()))
<a name="l00207"></a>00207         {
<a name="l00208"></a>00208                 cout &lt;&lt; <span class="stringliteral">&quot;FAILED    simple agreed values not equal&quot;</span> &lt;&lt; endl;
<a name="l00209"></a>00209                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         cout &lt;&lt; <span class="stringliteral">&quot;passed    simple key agreement&quot;</span> &lt;&lt; endl;
<a name="l00213"></a>00213         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00214"></a>00214 }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keywordtype">bool</span> AuthenticatedKeyAgreementValidate(<a class="code" href="class_authenticated_key_agreement_domain.html" title="interface for domains of authenticated key agreement protocols">AuthenticatedKeyAgreementDomain</a> &amp;d)
<a name="l00217"></a>00217 {
<a name="l00218"></a>00218         <span class="keywordflow">if</span> (d.GetCryptoParameters().<a class="code" href="class_crypto_material.html#aaa7d67d0c12712de0e33713c73f5b718" title="check this object for errors">Validate</a>(GlobalRNG(), 3))
<a name="l00219"></a>00219                 cout &lt;&lt; <span class="stringliteral">&quot;passed    authenticated key agreement domain parameters validation&quot;</span> &lt;&lt; endl;
<a name="l00220"></a>00220         <span class="keywordflow">else</span>
<a name="l00221"></a>00221         {
<a name="l00222"></a>00222                 cout &lt;&lt; <span class="stringliteral">&quot;FAILED    authenticated key agreement domain parameters invalid&quot;</span> &lt;&lt; endl;
<a name="l00223"></a>00223                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         <a class="code" href="class_sec_block.html">SecByteBlock</a> spriv1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a1ede4e454e74031ec0f0786dc2a14ddf" title="return length of static private keys in this domain">StaticPrivateKeyLength</a>()), spriv2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a1ede4e454e74031ec0f0786dc2a14ddf" title="return length of static private keys in this domain">StaticPrivateKeyLength</a>());
<a name="l00227"></a>00227         <a class="code" href="class_sec_block.html">SecByteBlock</a> epriv1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a449deae54019f6dfc9677e721a193004" title="return length of ephemeral private keys in this domain">EphemeralPrivateKeyLength</a>()), epriv2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a449deae54019f6dfc9677e721a193004" title="return length of ephemeral private keys in this domain">EphemeralPrivateKeyLength</a>());
<a name="l00228"></a>00228         <a class="code" href="class_sec_block.html">SecByteBlock</a> spub1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#aa7a7a1a641b21fb55cfec96cbf029795" title="return length of static public keys in this domain">StaticPublicKeyLength</a>()), spub2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#aa7a7a1a641b21fb55cfec96cbf029795" title="return length of static public keys in this domain">StaticPublicKeyLength</a>());
<a name="l00229"></a>00229         <a class="code" href="class_sec_block.html">SecByteBlock</a> epub1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a3dbef507ea4fd300ad8b2afb4d7afbe9" title="return length of ephemeral public keys in this domain">EphemeralPublicKeyLength</a>()), epub2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a3dbef507ea4fd300ad8b2afb4d7afbe9" title="return length of ephemeral public keys in this domain">EphemeralPublicKeyLength</a>());
<a name="l00230"></a>00230         <a class="code" href="class_sec_block.html">SecByteBlock</a> val1(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a98ff4ab957b445060f06c95636a098ea" title="return length of agreed value produced">AgreedValueLength</a>()), val2(d.<a class="code" href="class_authenticated_key_agreement_domain.html#a98ff4ab957b445060f06c95636a098ea" title="return length of agreed value produced">AgreedValueLength</a>());
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         d.<a class="code" href="class_authenticated_key_agreement_domain.html#ae2c306a6582c6e592ecb2c13abfd7c9f" title="generate private/public key pair">GenerateStaticKeyPair</a>(GlobalRNG(), spriv1, spub1);
<a name="l00233"></a>00233         d.<a class="code" href="class_authenticated_key_agreement_domain.html#ae2c306a6582c6e592ecb2c13abfd7c9f" title="generate private/public key pair">GenerateStaticKeyPair</a>(GlobalRNG(), spriv2, spub2);
<a name="l00234"></a>00234         d.<a class="code" href="class_authenticated_key_agreement_domain.html#a18f1fc5fa590be704d53759e44fba093" title="generate private/public key pair">GenerateEphemeralKeyPair</a>(GlobalRNG(), epriv1, epub1);
<a name="l00235"></a>00235         d.<a class="code" href="class_authenticated_key_agreement_domain.html#a18f1fc5fa590be704d53759e44fba093" title="generate private/public key pair">GenerateEphemeralKeyPair</a>(GlobalRNG(), epriv2, epub2);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237         memset(val1.begin(), 0x10, val1.size());
<a name="l00238"></a>00238         memset(val2.begin(), 0x11, val2.size());
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         <span class="keywordflow">if</span> (!(d.<a class="code" href="class_authenticated_key_agreement_domain.html#ac9808fb56eacee0c08a9bbd22fe2c98e" title="derive agreed value from your private keys and couterparty&amp;#39;s public keys, return false in case of...">Agree</a>(val1, spriv1, epriv1, spub2, epub2) &amp;&amp; d.<a class="code" href="class_authenticated_key_agreement_domain.html#ac9808fb56eacee0c08a9bbd22fe2c98e" title="derive agreed value from your private keys and couterparty&amp;#39;s public keys, return false in case of...">Agree</a>(val2, spriv2, epriv2, spub1, epub1)))
<a name="l00241"></a>00241         {
<a name="l00242"></a>00242                 cout &lt;&lt; <span class="stringliteral">&quot;FAILED    authenticated key agreement failed&quot;</span> &lt;&lt; endl;
<a name="l00243"></a>00243                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (memcmp(val1.begin(), val2.begin(), d.<a class="code" href="class_authenticated_key_agreement_domain.html#a98ff4ab957b445060f06c95636a098ea" title="return length of agreed value produced">AgreedValueLength</a>()))
<a name="l00247"></a>00247         {
<a name="l00248"></a>00248                 cout &lt;&lt; <span class="stringliteral">&quot;FAILED    authenticated agreed values not equal&quot;</span> &lt;&lt; endl;
<a name="l00249"></a>00249                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         cout &lt;&lt; <span class="stringliteral">&quot;passed    authenticated key agreement&quot;</span> &lt;&lt; endl;
<a name="l00253"></a>00253         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00254"></a>00254 }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="keywordtype">bool</span> ValidateRSA()
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258         cout &lt;&lt; <span class="stringliteral">&quot;\nRSA validation suite running...\n\n&quot;</span>;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         byte out[100], outPlain[100];
<a name="l00261"></a>00261         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         {
<a name="l00264"></a>00264                 <span class="keyword">const</span> <span class="keywordtype">char</span> *plain = <span class="stringliteral">&quot;Everyone gets Friday off.&quot;</span>;
<a name="l00265"></a>00265                 byte *signature = (byte *)
<a name="l00266"></a>00266                         <span class="stringliteral">&quot;\x05\xfa\x6a\x81\x2f\xc7\xdf\x8b\xf4\xf2\x54\x25\x09\xe0\x3e\x84&quot;</span>
<a name="l00267"></a>00267                         <span class="stringliteral">&quot;\x6e\x11\xb9\xc6\x20\xbe\x20\x09\xef\xb4\x40\xef\xbc\xc6\x69\x21&quot;</span>
<a name="l00268"></a>00268                         <span class="stringliteral">&quot;\x69\x94\xac\x04\xf3\x41\xb5\x7d\x05\x20\x2d\x42\x8f\xb2\xa2\x7b&quot;</span>
<a name="l00269"></a>00269                         <span class="stringliteral">&quot;\x5c\x77\xdf\xd9\xb1\x5b\xfc\x3d\x55\x93\x53\x50\x34\x10\xc1\xe1&quot;</span>;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> keys(<span class="stringliteral">&quot;TestData/rsa512a.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00272"></a>00272                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">Weak::RSASSA_PKCS1v15_MD2_Signer</a> rsaPriv(keys);
<a name="l00273"></a>00273                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">Weak::RSASSA_PKCS1v15_MD2_Verifier</a> rsaPub(rsaPriv);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275                 <span class="keywordtype">size_t</span> signatureLength = rsaPriv.SignMessage(GlobalRNG(), (byte *)plain, strlen(plain), out);
<a name="l00276"></a>00276                 fail = memcmp(signature, out, 64) != 0;
<a name="l00277"></a>00277                 pass = pass &amp;&amp; !fail;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00280"></a>00280                 cout &lt;&lt; <span class="stringliteral">&quot;signature check against test vector\n&quot;</span>;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282                 fail = !rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);
<a name="l00283"></a>00283                 pass = pass &amp;&amp; !fail;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00286"></a>00286                 cout &lt;&lt; <span class="stringliteral">&quot;verification check against test vector\n&quot;</span>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288                 out[10]++;
<a name="l00289"></a>00289                 fail = rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);
<a name="l00290"></a>00290                 pass = pass &amp;&amp; !fail;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00293"></a>00293                 cout &lt;&lt; <span class="stringliteral">&quot;invalid signature verification\n&quot;</span>;
<a name="l00294"></a>00294         }
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> keys(<span class="stringliteral">&quot;TestData/rsa1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00297"></a>00297                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_PKCS1v15_Decryptor</a> rsaPriv(keys);
<a name="l00298"></a>00298                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_PKCS1v15_Encryptor</a> rsaPub(rsaPriv);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300                 pass = CryptoSystemValidate(rsaPriv, rsaPub) &amp;&amp; pass;
<a name="l00301"></a>00301         }
<a name="l00302"></a>00302         {
<a name="l00303"></a>00303                 <a class="code" href="struct_r_s_a_e_s.html" title="RSA cryptosystem">RSAES&lt;OAEP&lt;SHA&gt;</a> &gt;::Decryptor rsaPriv(GlobalRNG(), 512);
<a name="l00304"></a>00304                 <a class="code" href="struct_r_s_a_e_s.html" title="RSA cryptosystem">RSAES&lt;OAEP&lt;SHA&gt;</a> &gt;::Encryptor rsaPub(rsaPriv);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306                 pass = CryptoSystemValidate(rsaPriv, rsaPub) &amp;&amp; pass;
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308         {
<a name="l00309"></a>00309                 byte *plain = (byte *)
<a name="l00310"></a>00310                         <span class="stringliteral">&quot;\x54\x85\x9b\x34\x2c\x49\xea\x2a&quot;</span>;
<a name="l00311"></a>00311                 byte *encrypted = (byte *)
<a name="l00312"></a>00312                         <span class="stringliteral">&quot;\x14\xbd\xdd\x28\xc9\x83\x35\x19\x23\x80\xe8\xe5\x49\xb1\x58\x2a&quot;</span>
<a name="l00313"></a>00313                         <span class="stringliteral">&quot;\x8b\x40\xb4\x48\x6d\x03\xa6\xa5\x31\x1f\x1f\xd5\xf0\xa1\x80\xe4&quot;</span>
<a name="l00314"></a>00314                         <span class="stringliteral">&quot;\x17\x53\x03\x29\xa9\x34\x90\x74\xb1\x52\x13\x54\x29\x08\x24\x52&quot;</span>
<a name="l00315"></a>00315                         <span class="stringliteral">&quot;\x62\x51&quot;</span>;
<a name="l00316"></a>00316                 byte *oaepSeed = (byte *)
<a name="l00317"></a>00317                         <span class="stringliteral">&quot;\xaa\xfd\x12\xf6\x59\xca\xe6\x34\x89\xb4\x79\xe5\x07\x6d\xde\xc2&quot;</span>
<a name="l00318"></a>00318                         <span class="stringliteral">&quot;\xf0\x6c\xb5\x8f&quot;</span>;
<a name="l00319"></a>00319                 <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> bq;
<a name="l00320"></a>00320                 bq.<a class="code" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede" title="input a byte for processing">Put</a>(oaepSeed, 20);
<a name="l00321"></a>00321                 <a class="code" href="class_fixed_r_n_g.html">FixedRNG</a> rng(bq);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> privFile(<span class="stringliteral">&quot;TestData/rsa400pv.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00324"></a>00324                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> pubFile(<span class="stringliteral">&quot;TestData/rsa400pb.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00325"></a>00325                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_OAEP_SHA_Decryptor</a> rsaPriv;
<a name="l00326"></a>00326                 rsaPriv.AccessKey().BERDecodePrivateKey(privFile, <span class="keyword">false</span>, 0);
<a name="l00327"></a>00327                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RSAES_OAEP_SHA_Encryptor</a> rsaPub(pubFile);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329                 memset(out, 0, 50);
<a name="l00330"></a>00330                 memset(outPlain, 0, 8);
<a name="l00331"></a>00331                 rsaPub.Encrypt(rng, plain, 8, out);
<a name="l00332"></a>00332                 <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> result = rsaPriv.FixedLengthDecrypt(GlobalRNG(), encrypted, outPlain);
<a name="l00333"></a>00333                 fail = !result.isValidCoding || (result.messageLength!=8) || memcmp(out, encrypted, 50) || memcmp(plain, outPlain, 8);
<a name="l00334"></a>00334                 pass = pass &amp;&amp; !fail;
<a name="l00335"></a>00335 
<a name="l00336"></a>00336                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00337"></a>00337                 cout &lt;&lt; <span class="stringliteral">&quot;PKCS 2.0 encryption and decryption\n&quot;</span>;
<a name="l00338"></a>00338         }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="keywordflow">return</span> pass;
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 <span class="keywordtype">bool</span> ValidateDH()
<a name="l00344"></a>00344 {
<a name="l00345"></a>00345         cout &lt;&lt; <span class="stringliteral">&quot;\nDH validation suite running...\n\n&quot;</span>;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/dh1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00348"></a>00348         <a class="code" href="class_d_h___domain.html" title=",">DH</a> dh(f);
<a name="l00349"></a>00349         <span class="keywordflow">return</span> SimpleKeyAgreementValidate(dh);
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="keywordtype">bool</span> ValidateMQV()
<a name="l00353"></a>00353 {
<a name="l00354"></a>00354         cout &lt;&lt; <span class="stringliteral">&quot;\nMQV validation suite running...\n\n&quot;</span>;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/mqv1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00357"></a>00357         <a class="code" href="class_m_q_v___domain.html" title="_">MQV</a> mqv(f);
<a name="l00358"></a>00358         <span class="keywordflow">return</span> AuthenticatedKeyAgreementValidate(mqv);
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="keywordtype">bool</span> ValidateLUC_DH()
<a name="l00362"></a>00362 {
<a name="l00363"></a>00363         cout &lt;&lt; <span class="stringliteral">&quot;\nLUC-DH validation suite running...\n\n&quot;</span>;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/lucd512.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00366"></a>00366         <a class="code" href="class_d_h___domain.html" title=",">LUC_DH</a> dh(f);
<a name="l00367"></a>00367         <span class="keywordflow">return</span> SimpleKeyAgreementValidate(dh);
<a name="l00368"></a>00368 }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="keywordtype">bool</span> ValidateXTR_DH()
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372         cout &lt;&lt; <span class="stringliteral">&quot;\nXTR-DH validation suite running...\n\n&quot;</span>;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/xtrdh171.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00375"></a>00375         <a class="code" href="class_x_t_r___d_h.html" title="XTR-DH with key validation.">XTR_DH</a> dh(f);
<a name="l00376"></a>00376         <span class="keywordflow">return</span> SimpleKeyAgreementValidate(dh);
<a name="l00377"></a>00377 }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="keywordtype">bool</span> ValidateElGamal()
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381         cout &lt;&lt; <span class="stringliteral">&quot;\nElGamal validation suite running...\n\n&quot;</span>;
<a name="l00382"></a>00382         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00383"></a>00383         {
<a name="l00384"></a>00384                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fc(<span class="stringliteral">&quot;TestData/elgc1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00385"></a>00385                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ElGamalDecryptor</a> privC(fc);
<a name="l00386"></a>00386                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ElGamalEncryptor</a> pubC(privC);
<a name="l00387"></a>00387                 privC.AccessKey().Precompute();
<a name="l00388"></a>00388                 <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> queue;
<a name="l00389"></a>00389                 privC.AccessKey().SavePrecomputation(queue);
<a name="l00390"></a>00390                 privC.AccessKey().LoadPrecomputation(queue);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392                 pass = CryptoSystemValidate(privC, pubC) &amp;&amp; pass;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394         <span class="keywordflow">return</span> pass;
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="keywordtype">bool</span> ValidateDLIES()
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399         cout &lt;&lt; <span class="stringliteral">&quot;\nDLIES validation suite running...\n\n&quot;</span>;
<a name="l00400"></a>00400         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00401"></a>00401         {
<a name="l00402"></a>00402                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fc(<span class="stringliteral">&quot;TestData/dlie1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00403"></a>00403                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DLIES&lt;&gt;::Decryptor</a> privC(fc);
<a name="l00404"></a>00404                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DLIES&lt;&gt;::Encryptor</a> pubC(privC);
<a name="l00405"></a>00405                 pass = CryptoSystemValidate(privC, pubC) &amp;&amp; pass;
<a name="l00406"></a>00406         }
<a name="l00407"></a>00407         {
<a name="l00408"></a>00408                 cout &lt;&lt; <span class="stringliteral">&quot;Generating new encryption key...&quot;</span> &lt;&lt; endl;
<a name="l00409"></a>00409                 <a class="code" href="class_d_l___group_parameters___g_f_p___default_safe_prime.html" title="GF(p) group parameters that default to same primes.">DLIES&lt;&gt;::GroupParameters</a> gp;
<a name="l00410"></a>00410                 gp.<a class="code" href="class_generatable_crypto_material.html#a38d492343c32e530a5c2781b5797f755" title="calls the above function with a NameValuePairs object that just specifies &amp;quot;KeySize&amp;quot;">GenerateRandomWithKeySize</a>(GlobalRNG(), 128);
<a name="l00411"></a>00411                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DLIES&lt;&gt;::Decryptor</a> decryptor;
<a name="l00412"></a>00412                 decryptor.AccessKey().GenerateRandom(GlobalRNG(), gp);
<a name="l00413"></a>00413                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DLIES&lt;&gt;::Encryptor</a> encryptor(decryptor);
<a name="l00414"></a>00414 
<a name="l00415"></a>00415                 pass = CryptoSystemValidate(decryptor, encryptor) &amp;&amp; pass;
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417         <span class="keywordflow">return</span> pass;
<a name="l00418"></a>00418 }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="keywordtype">bool</span> ValidateNR()
<a name="l00421"></a>00421 {
<a name="l00422"></a>00422         cout &lt;&lt; <span class="stringliteral">&quot;\nNR validation suite running...\n\n&quot;</span>;
<a name="l00423"></a>00423         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00424"></a>00424         {
<a name="l00425"></a>00425                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/nr2048.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00426"></a>00426                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">NR&lt;SHA&gt;::Signer</a> privS(f);
<a name="l00427"></a>00427                 privS.AccessKey().Precompute();
<a name="l00428"></a>00428                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">NR&lt;SHA&gt;::Verifier</a> pubS(privS);
<a name="l00429"></a>00429 
<a name="l00430"></a>00430                 pass = SignatureValidate(privS, pubS) &amp;&amp; pass;
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432         {
<a name="l00433"></a>00433                 cout &lt;&lt; <span class="stringliteral">&quot;Generating new signature key...&quot;</span> &lt;&lt; endl;
<a name="l00434"></a>00434                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">NR&lt;SHA&gt;::Signer</a> privS(GlobalRNG(), 256);
<a name="l00435"></a>00435                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">NR&lt;SHA&gt;::Verifier</a> pubS(privS);
<a name="l00436"></a>00436 
<a name="l00437"></a>00437                 pass = SignatureValidate(privS, pubS) &amp;&amp; pass;
<a name="l00438"></a>00438         }
<a name="l00439"></a>00439         <span class="keywordflow">return</span> pass;
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="keywordtype">bool</span> ValidateDSA(<span class="keywordtype">bool</span> thorough)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444         cout &lt;&lt; <span class="stringliteral">&quot;\nDSA validation suite running...\n\n&quot;</span>;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00447"></a>00447         {
<a name="l00448"></a>00448         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fs(<span class="stringliteral">&quot;TestData/dsa512.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00449"></a>00449         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">GDSA&lt;SHA&gt;::Signer</a> priv(fs);
<a name="l00450"></a>00450         priv.AccessKey().Precompute(16);
<a name="l00451"></a>00451         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">GDSA&lt;SHA&gt;::Verifier</a> pub(priv);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         byte seed[]={0xd5, 0x01, 0x4e, 0x4b, 0x60, 0xef, 0x2b, 0xa8, 0xb6, 0x21, 
<a name="l00454"></a>00454                                  0x1b, 0x40, 0x62, 0xba, 0x32, 0x24, 0xe0, 0x42, 0x7d, 0xd3};
<a name="l00455"></a>00455         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> k(<span class="stringliteral">&quot;358dad57 1462710f 50e254cf 1a376b2b deaadfbfh&quot;</span>);
<a name="l00456"></a>00456         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> h(<span class="stringliteral">&quot;a9993e36 4706816a ba3e2571 7850c26c 9cd0d89dh&quot;</span>);
<a name="l00457"></a>00457         byte sig[]={0x8b, 0xac, 0x1a, 0xb6, 0x64, 0x10, 0x43, 0x5c, 0xb7, 0x18,
<a name="l00458"></a>00458                                 0x1f, 0x95, 0xb1, 0x6a, 0xb9, 0x7c, 0x92, 0xb3, 0x41, 0xc0, 
<a name="l00459"></a>00459                                 0x41, 0xe2, 0x34, 0x5f, 0x1f, 0x56, 0xdf, 0x24, 0x58, 0xf4, 
<a name="l00460"></a>00460                                 0x26, 0xd1, 0x55, 0xb4, 0xba, 0x2d, 0xb6, 0xdc, 0xd8, 0xc8};
<a name="l00461"></a>00461         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> r(sig, 20);
<a name="l00462"></a>00462         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> s(sig+20, 20);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> pGen, qGen, rOut, sOut;
<a name="l00465"></a>00465         <span class="keywordtype">int</span> c;
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         fail = !<a class="code" href="struct_d_s_a.html#a48eab0da4234a2d20f3ef7250fbad5f5" title="Generate DSA primes according to NIST standard.">DSA::GeneratePrimes</a>(seed, 160, c, pGen, 512, qGen);
<a name="l00468"></a>00468         fail = fail || (pGen != pub.GetKey().GetGroupParameters().GetModulus()) || (qGen != pub.GetKey().GetGroupParameters().GetSubgroupOrder());
<a name="l00469"></a>00469         pass = pass &amp;&amp; !fail;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00472"></a>00472         cout &lt;&lt; <span class="stringliteral">&quot;prime generation test\n&quot;</span>;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474         priv.RawSign(k, h, rOut, sOut);
<a name="l00475"></a>00475         fail = (rOut != r) || (sOut != s);
<a name="l00476"></a>00476         pass = pass &amp;&amp; !fail;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00479"></a>00479         cout &lt;&lt; <span class="stringliteral">&quot;signature check against test vector\n&quot;</span>;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         fail = !pub.VerifyMessage((byte *)<span class="stringliteral">&quot;abc&quot;</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00482"></a>00482         pass = pass &amp;&amp; !fail;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00485"></a>00485         cout &lt;&lt; <span class="stringliteral">&quot;verification check against test vector\n&quot;</span>;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         fail = pub.VerifyMessage((byte *)<span class="stringliteral">&quot;xyz&quot;</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00488"></a>00488         pass = pass &amp;&amp; !fail;
<a name="l00489"></a>00489         }
<a name="l00490"></a>00490         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fs1(<span class="stringliteral">&quot;TestData/dsa1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00491"></a>00491         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DSA::Signer</a> priv(fs1);
<a name="l00492"></a>00492         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DSA::Verifier</a> pub(priv);
<a name="l00493"></a>00493         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fs2(<span class="stringliteral">&quot;TestData/dsa1024b.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>());
<a name="l00494"></a>00494         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">DSA::Verifier</a> pub1(fs2);
<a name="l00495"></a>00495         assert(pub.GetKey() == pub1.GetKey());
<a name="l00496"></a>00496         pass = SignatureValidate(priv, pub, thorough) &amp;&amp; pass;
<a name="l00497"></a>00497         <span class="keywordflow">return</span> pass;
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="keywordtype">bool</span> ValidateLUC()
<a name="l00501"></a>00501 {
<a name="l00502"></a>00502         cout &lt;&lt; <span class="stringliteral">&quot;\nLUC validation suite running...\n\n&quot;</span>;
<a name="l00503"></a>00503         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>;
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         {
<a name="l00506"></a>00506                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/luc1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00507"></a>00507                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCSSA_PKCS1v15_SHA_Signer</a> priv(f);
<a name="l00508"></a>00508                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCSSA_PKCS1v15_SHA_Verifier</a> pub(priv);
<a name="l00509"></a>00509                 pass = SignatureValidate(priv, pub) &amp;&amp; pass;
<a name="l00510"></a>00510         }
<a name="l00511"></a>00511         {
<a name="l00512"></a>00512                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCES_OAEP_SHA_Decryptor</a> priv(GlobalRNG(), 512);
<a name="l00513"></a>00513                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUCES_OAEP_SHA_Encryptor</a> pub(priv);
<a name="l00514"></a>00514                 pass = CryptoSystemValidate(priv, pub) &amp;&amp; pass;
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516         <span class="keywordflow">return</span> pass;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="keywordtype">bool</span> ValidateLUC_DL()
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521         cout &lt;&lt; <span class="stringliteral">&quot;\nLUC-HMP validation suite running...\n\n&quot;</span>;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/lucs512.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00524"></a>00524         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUC_HMP&lt;SHA&gt;::Signer</a> privS(f);
<a name="l00525"></a>00525         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUC_HMP&lt;SHA&gt;::Verifier</a> pubS(privS);
<a name="l00526"></a>00526         <span class="keywordtype">bool</span> pass = SignatureValidate(privS, pubS);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528         cout &lt;&lt; <span class="stringliteral">&quot;\nLUC-IES validation suite running...\n\n&quot;</span>;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> fc(<span class="stringliteral">&quot;TestData/lucc512.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00531"></a>00531         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUC_IES&lt;&gt;::Decryptor</a> privC(fc);
<a name="l00532"></a>00532         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">LUC_IES&lt;&gt;::Encryptor</a> pubC(privC);
<a name="l00533"></a>00533         pass = CryptoSystemValidate(privC, pubC) &amp;&amp; pass;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <span class="keywordflow">return</span> pass;
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="keywordtype">bool</span> ValidateRabin()
<a name="l00539"></a>00539 {
<a name="l00540"></a>00540         cout &lt;&lt; <span class="stringliteral">&quot;\nRabin validation suite running...\n\n&quot;</span>;
<a name="l00541"></a>00541         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543         {
<a name="l00544"></a>00544                 <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/rabi1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00545"></a>00545                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RabinSS&lt;PSSR, SHA&gt;::Signer</a> priv(f);
<a name="l00546"></a>00546                 <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RabinSS&lt;PSSR, SHA&gt;::Verifier</a> pub(priv);
<a name="l00547"></a>00547                 pass = SignatureValidate(priv, pub) &amp;&amp; pass;
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549         {
<a name="l00550"></a>00550                 <a class="code" href="struct_rabin_e_s.html" title="Rabin encryption.">RabinES&lt;OAEP&lt;SHA&gt;</a> &gt;::Decryptor priv(GlobalRNG(), 512);
<a name="l00551"></a>00551                 <a class="code" href="struct_rabin_e_s.html" title="Rabin encryption.">RabinES&lt;OAEP&lt;SHA&gt;</a> &gt;::Encryptor pub(priv);
<a name="l00552"></a>00552                 pass = CryptoSystemValidate(priv, pub) &amp;&amp; pass;
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554         <span class="keywordflow">return</span> pass;
<a name="l00555"></a>00555 }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 <span class="keywordtype">bool</span> ValidateRW()
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559         cout &lt;&lt; <span class="stringliteral">&quot;\nRW validation suite running...\n\n&quot;</span>;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> f(<span class="stringliteral">&quot;TestData/rw1024.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00562"></a>00562         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RWSS&lt;PSSR, SHA&gt;::Signer</a> priv(f);
<a name="l00563"></a>00563         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">RWSS&lt;PSSR, SHA&gt;::Verifier</a> pub(priv);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565         <span class="keywordflow">return</span> SignatureValidate(priv, pub);
<a name="l00566"></a>00566 }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 <span class="comment">/*</span>
<a name="l00569"></a>00569 <span class="comment">bool ValidateBlumGoldwasser()</span>
<a name="l00570"></a>00570 <span class="comment">{</span>
<a name="l00571"></a>00571 <span class="comment">        cout &lt;&lt; &quot;\nBlumGoldwasser validation suite running...\n\n&quot;;</span>
<a name="l00572"></a>00572 <span class="comment"></span>
<a name="l00573"></a>00573 <span class="comment">        FileSource f(&quot;TestData/blum512.dat&quot;, true, new HexDecoder);</span>
<a name="l00574"></a>00574 <span class="comment">        BlumGoldwasserPrivateKey priv(f);</span>
<a name="l00575"></a>00575 <span class="comment">        BlumGoldwasserPublicKey pub(priv);</span>
<a name="l00576"></a>00576 <span class="comment"></span>
<a name="l00577"></a>00577 <span class="comment">        return CryptoSystemValidate(priv, pub);</span>
<a name="l00578"></a>00578 <span class="comment">}</span>
<a name="l00579"></a>00579 <span class="comment">*/</span>
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keywordtype">bool</span> ValidateECP()
<a name="l00582"></a>00582 {
<a name="l00583"></a>00583         cout &lt;&lt; <span class="stringliteral">&quot;\nECP validation suite running...\n\n&quot;</span>;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECIES&lt;ECP&gt;::Decryptor</a> cpriv(GlobalRNG(), ASN1::secp192r1());
<a name="l00586"></a>00586         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECIES&lt;ECP&gt;::Encryptor</a> cpub(cpriv);
<a name="l00587"></a>00587         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> bq;
<a name="l00588"></a>00588         cpriv.GetKey().DEREncode(bq);
<a name="l00589"></a>00589         cpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(<span class="keyword">true</span>);
<a name="l00590"></a>00590         cpub.GetKey().DEREncode(bq);
<a name="l00591"></a>00591         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECDSA&lt;ECP, SHA&gt;::Signer</a> spriv(bq);
<a name="l00592"></a>00592         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECDSA&lt;ECP, SHA&gt;::Verifier</a> spub(bq);
<a name="l00593"></a>00593         <a class="code" href="class_d_h___domain.html" title=",">ECDH&lt;ECP&gt;::Domain</a> ecdhc(ASN1::secp192r1());
<a name="l00594"></a>00594         <a class="code" href="class_m_q_v___domain.html" title="_">ECMQV&lt;ECP&gt;::Domain</a> ecmqvc(ASN1::secp192r1());
<a name="l00595"></a>00595 
<a name="l00596"></a>00596         spriv.AccessKey().Precompute();
<a name="l00597"></a>00597         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> queue;
<a name="l00598"></a>00598         spriv.AccessKey().SavePrecomputation(queue);
<a name="l00599"></a>00599         spriv.AccessKey().LoadPrecomputation(queue);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         <span class="keywordtype">bool</span> pass = SignatureValidate(spriv, spub);
<a name="l00602"></a>00602         cpub.AccessKey().Precompute();
<a name="l00603"></a>00603         cpriv.AccessKey().Precompute();
<a name="l00604"></a>00604         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00605"></a>00605         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00606"></a>00606         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         cout &lt;&lt; <span class="stringliteral">&quot;Turning on point compression...&quot;</span> &lt;&lt; endl;
<a name="l00609"></a>00609         cpriv.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00610"></a>00610         cpub.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00611"></a>00611         ecdhc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00612"></a>00612         ecmqvc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00613"></a>00613         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00614"></a>00614         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00615"></a>00615         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         cout &lt;&lt; <span class="stringliteral">&quot;Testing SEC 2, NIST, and Brainpool recommended curves...&quot;</span> &lt;&lt; endl;
<a name="l00618"></a>00618         <a class="code" href="class_o_i_d.html" title="Object Identifier.">OID</a> oid;
<a name="l00619"></a>00619         <span class="keywordflow">while</span> (!(oid = <a class="code" href="class_d_l___group_parameters___e_c.html" title="Elliptic Curve Parameters.">DL_GroupParameters_EC&lt;ECP&gt;::GetNextRecommendedParametersOID</a>(oid)).m_values.empty())
<a name="l00620"></a>00620         {
<a name="l00621"></a>00621                 <a class="code" href="class_d_l___group_parameters___e_c.html" title="Elliptic Curve Parameters.">DL_GroupParameters_EC&lt;ECP&gt;</a> params(oid);
<a name="l00622"></a>00622                 <span class="keywordtype">bool</span> fail = !params.Validate(GlobalRNG(), 2);
<a name="l00623"></a>00623                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED&quot;</span> : <span class="stringliteral">&quot;passed&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; dec &lt;&lt; params.GetCurve().GetField().MaxElementBitLength() &lt;&lt; <span class="stringliteral">&quot; bits&quot;</span> &lt;&lt; endl;
<a name="l00624"></a>00624                 pass = pass &amp;&amp; !fail;
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         <span class="keywordflow">return</span> pass;
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="keywordtype">bool</span> ValidateEC2N()
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632         cout &lt;&lt; <span class="stringliteral">&quot;\nEC2N validation suite running...\n\n&quot;</span>;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECIES&lt;EC2N&gt;::Decryptor</a> cpriv(GlobalRNG(), ASN1::sect193r1());
<a name="l00635"></a>00635         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECIES&lt;EC2N&gt;::Encryptor</a> cpub(cpriv);
<a name="l00636"></a>00636         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> bq;
<a name="l00637"></a>00637         cpriv.DEREncode(bq);
<a name="l00638"></a>00638         cpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(<span class="keyword">true</span>);
<a name="l00639"></a>00639         cpub.DEREncode(bq);
<a name="l00640"></a>00640         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECDSA&lt;EC2N, SHA&gt;::Signer</a> spriv(bq);
<a name="l00641"></a>00641         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECDSA&lt;EC2N, SHA&gt;::Verifier</a> spub(bq);
<a name="l00642"></a>00642         <a class="code" href="class_d_h___domain.html" title=",">ECDH&lt;EC2N&gt;::Domain</a> ecdhc(ASN1::sect193r1());
<a name="l00643"></a>00643         <a class="code" href="class_m_q_v___domain.html" title="_">ECMQV&lt;EC2N&gt;::Domain</a> ecmqvc(ASN1::sect193r1());
<a name="l00644"></a>00644 
<a name="l00645"></a>00645         spriv.AccessKey().Precompute();
<a name="l00646"></a>00646         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> queue;
<a name="l00647"></a>00647         spriv.AccessKey().SavePrecomputation(queue);
<a name="l00648"></a>00648         spriv.AccessKey().LoadPrecomputation(queue);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         <span class="keywordtype">bool</span> pass = SignatureValidate(spriv, spub);
<a name="l00651"></a>00651         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00652"></a>00652         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00653"></a>00653         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         cout &lt;&lt; <span class="stringliteral">&quot;Turning on point compression...&quot;</span> &lt;&lt; endl;
<a name="l00656"></a>00656         cpriv.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00657"></a>00657         cpub.AccessKey().AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00658"></a>00658         ecdhc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00659"></a>00659         ecmqvc.AccessGroupParameters().SetPointCompression(<span class="keyword">true</span>);
<a name="l00660"></a>00660         pass = CryptoSystemValidate(cpriv, cpub) &amp;&amp; pass;
<a name="l00661"></a>00661         pass = SimpleKeyAgreementValidate(ecdhc) &amp;&amp; pass;
<a name="l00662"></a>00662         pass = AuthenticatedKeyAgreementValidate(ecmqvc) &amp;&amp; pass;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664 <span class="preprocessor">#if 0   // TODO: turn this back on when I make EC2N faster for pentanomial basis</span>
<a name="l00665"></a>00665 <span class="preprocessor"></span>        cout &lt;&lt; <span class="stringliteral">&quot;Testing SEC 2 recommended curves...&quot;</span> &lt;&lt; endl;
<a name="l00666"></a>00666         <a class="code" href="class_o_i_d.html" title="Object Identifier.">OID</a> oid;
<a name="l00667"></a>00667         <span class="keywordflow">while</span> (!(oid = <a class="code" href="class_d_l___group_parameters___e_c.html" title="Elliptic Curve Parameters.">DL_GroupParameters_EC&lt;EC2N&gt;::GetNextRecommendedParametersOID</a>(oid)).m_values.empty())
<a name="l00668"></a>00668         {
<a name="l00669"></a>00669                 <a class="code" href="class_d_l___group_parameters___e_c.html" title="Elliptic Curve Parameters.">DL_GroupParameters_EC&lt;EC2N&gt;</a> params(oid);
<a name="l00670"></a>00670                 <span class="keywordtype">bool</span> fail = !params.Validate(GlobalRNG(), 2);
<a name="l00671"></a>00671                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED&quot;</span> : <span class="stringliteral">&quot;passed&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; params.GetCurve().GetField().MaxElementBitLength() &lt;&lt; <span class="stringliteral">&quot; bits&quot;</span> &lt;&lt; endl;
<a name="l00672"></a>00672                 pass = pass &amp;&amp; !fail;
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674 <span class="preprocessor">#endif</span>
<a name="l00675"></a>00675 <span class="preprocessor"></span>
<a name="l00676"></a>00676         <span class="keywordflow">return</span> pass;
<a name="l00677"></a>00677 }
<a name="l00678"></a>00678 
<a name="l00679"></a>00679 <span class="keywordtype">bool</span> ValidateECDSA()
<a name="l00680"></a>00680 {
<a name="l00681"></a>00681         cout &lt;&lt; <span class="stringliteral">&quot;\nECDSA validation suite running...\n\n&quot;</span>;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <span class="comment">// from Sample Test Vectors for P1363</span>
<a name="l00684"></a>00684         <a class="code" href="class_g_f2_n_t.html" title="GF(2^n) with Trinomial Basis.">GF2NT</a> gf2n(191, 9, 0);
<a name="l00685"></a>00685         byte a[]=<span class="stringliteral">&quot;\x28\x66\x53\x7B\x67\x67\x52\x63\x6A\x68\xF5\x65\x54\xE1\x26\x40\x27\x6B\x64\x9E\xF7\x52\x62\x67&quot;</span>;
<a name="l00686"></a>00686         byte b[]=<span class="stringliteral">&quot;\x2E\x45\xEF\x57\x1F\x00\x78\x6F\x67\xB0\x08\x1B\x94\x95\xA3\xD9\x54\x62\xF5\xDE\x0A\xA1\x85\xEC&quot;</span>;
<a name="l00687"></a>00687         <a class="code" href="class_e_c2_n.html" title="Elliptic Curve over GF(2^n).">EC2N</a> ec(gf2n, <a class="code" href="class_polynomial_mod2.html" title="Polynomial with Coefficients in GF(2).">PolynomialMod2</a>(a,24), <a class="code" href="class_polynomial_mod2.html" title="Polynomial with Coefficients in GF(2).">PolynomialMod2</a>(b,24));
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         <a class="code" href="struct_e_c2_n_point.html" title="Elliptic Curve Point.">EC2N::Point</a> P;
<a name="l00690"></a>00690         ec.DecodePoint(P, (byte *)<span class="stringliteral">&quot;\x04\x36\xB3\xDA\xF8\xA2\x32\x06\xF9\xC4\xF2\x99\xD7\xB2\x1A\x9C\x36\x91\x37\xF2\xC8\x4A\xE1\xAA\x0D&quot;</span>
<a name="l00691"></a>00691                 <span class="stringliteral">&quot;\x76\x5B\xE7\x34\x33\xB3\xF9\x5E\x33\x29\x32\xE7\x0E\xA2\x45\xCA\x24\x18\xEA\x0E\xF9\x80\x18\xFB&quot;</span>, ec.EncodedPointSize());
<a name="l00692"></a>00692         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> n(<span class="stringliteral">&quot;40000000000000000000000004a20e90c39067c893bbb9a5H&quot;</span>);
<a name="l00693"></a>00693         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> d(<span class="stringliteral">&quot;340562e1dda332f9d2aec168249b5696ee39d0ed4d03760fH&quot;</span>);
<a name="l00694"></a>00694         <a class="code" href="struct_e_c2_n_point.html" title="Elliptic Curve Point.">EC2N::Point</a> Q(ec.Multiply(d, P));
<a name="l00695"></a>00695         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECDSA&lt;EC2N, SHA&gt;::Signer</a> priv(ec, P, n, d);
<a name="l00696"></a>00696         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ECDSA&lt;EC2N, SHA&gt;::Verifier</a> pub(priv);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> h(<span class="stringliteral">&quot;A9993E364706816ABA3E25717850C26C9CD0D89DH&quot;</span>);
<a name="l00699"></a>00699         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> k(<span class="stringliteral">&quot;3eeace72b4919d991738d521879f787cb590aff8189d2b69H&quot;</span>);
<a name="l00700"></a>00700         byte sig[]=<span class="stringliteral">&quot;\x03\x8e\x5a\x11\xfb\x55\xe4\xc6\x54\x71\xdc\xd4\x99\x84\x52\xb1\xe0\x2d\x8a\xf7\x09\x9b\xb9\x30&quot;</span>
<a name="l00701"></a>00701                 <span class="stringliteral">&quot;\x0c\x9a\x08\xc3\x44\x68\xc2\x44\xb4\xe5\xd6\xb2\x1b\x3c\x68\x36\x28\x07\x41\x60\x20\x32\x8b\x6e&quot;</span>;
<a name="l00702"></a>00702         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> r(sig, 24);
<a name="l00703"></a>00703         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> s(sig+24, 24);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         <a class="code" href="class_integer.html" title="multiple precision integer and basic arithmetics">Integer</a> rOut, sOut;
<a name="l00706"></a>00706         <span class="keywordtype">bool</span> fail, pass=<span class="keyword">true</span>;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708         priv.RawSign(k, h, rOut, sOut);
<a name="l00709"></a>00709         fail = (rOut != r) || (sOut != s);
<a name="l00710"></a>00710         pass = pass &amp;&amp; !fail;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00713"></a>00713         cout &lt;&lt; <span class="stringliteral">&quot;signature check against test vector\n&quot;</span>;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         fail = !pub.VerifyMessage((byte *)<span class="stringliteral">&quot;abc&quot;</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00716"></a>00716         pass = pass &amp;&amp; !fail;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00719"></a>00719         cout &lt;&lt; <span class="stringliteral">&quot;verification check against test vector\n&quot;</span>;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         fail = pub.VerifyMessage((byte *)<span class="stringliteral">&quot;xyz&quot;</span>, 3, sig, <span class="keyword">sizeof</span>(sig));
<a name="l00722"></a>00722         pass = pass &amp;&amp; !fail;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         pass = SignatureValidate(priv, pub) &amp;&amp; pass;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <span class="keywordflow">return</span> pass;
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 <span class="keywordtype">bool</span> ValidateESIGN()
<a name="l00730"></a>00730 {
<a name="l00731"></a>00731         cout &lt;&lt; <span class="stringliteral">&quot;\nESIGN validation suite running...\n\n&quot;</span>;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>, fail;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         <span class="keyword">const</span> <span class="keywordtype">char</span> *plain = <span class="stringliteral">&quot;test&quot;</span>;
<a name="l00736"></a>00736         <span class="keyword">const</span> byte *signature = (byte *)
<a name="l00737"></a>00737                 <span class="stringliteral">&quot;\xA3\xE3\x20\x65\xDE\xDA\xE7\xEC\x05\xC1\xBF\xCD\x25\x79\x7D\x99\xCD\xD5\x73\x9D\x9D\xF3\xA4\xAA\x9A\xA4\x5A\xC8\x23\x3D\x0D\x37\xFE\xBC\x76\x3F\xF1\x84\xF6\x59&quot;</span>
<a name="l00738"></a>00738                 <span class="stringliteral">&quot;\x14\x91\x4F\x0C\x34\x1B\xAE\x9A\x5C\x2E\x2E\x38\x08\x78\x77\xCB\xDC\x3C\x7E\xA0\x34\x44\x5B\x0F\x67\xD9\x35\x2A\x79\x47\x1A\x52\x37\x71\xDB\x12\x67\xC1\xB6\xC6&quot;</span>
<a name="l00739"></a>00739                 <span class="stringliteral">&quot;\x66\x73\xB3\x40\x2E\xD6\xF2\x1A\x84\x0A\xB6\x7B\x0F\xEB\x8B\x88\xAB\x33\xDD\xE4\x83\x21\x90\x63\x2D\x51\x2A\xB1\x6F\xAB\xA7\x5C\xFD\x77\x99\xF2\xE1\xEF\x67\x1A&quot;</span>
<a name="l00740"></a>00740                 <span class="stringliteral">&quot;\x74\x02\x37\x0E\xED\x0A\x06\xAD\xF4\x15\x65\xB8\xE1\xD1\x45\xAE\x39\x19\xB4\xFF\x5D\xF1\x45\x7B\xE0\xFE\x72\xED\x11\x92\x8F\x61\x41\x4F\x02\x00\xF2\x76\x6F\x7C&quot;</span>
<a name="l00741"></a>00741                 <span class="stringliteral">&quot;\x79\xA2\xE5\x52\x20\x5D\x97\x5E\xFE\x39\xAE\x21\x10\xFB\x35\xF4\x80\x81\x41\x13\xDD\xE8\x5F\xCA\x1E\x4F\xF8\x9B\xB2\x68\xFB\x28&quot;</span>;
<a name="l00742"></a>00742 
<a name="l00743"></a>00743         <a class="code" href="class_file_source.html" title="file-based implementation of Source interface">FileSource</a> keys(<span class="stringliteral">&quot;TestData/esig1536.dat&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>);
<a name="l00744"></a>00744         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ESIGN&lt;SHA&gt;::Signer</a> signer(keys);
<a name="l00745"></a>00745         <a class="code" href="class_p_k___final_template.html" title="A template implementing constructors for public key algorithm classes.">ESIGN&lt;SHA&gt;::Verifier</a> verifier(signer);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         fail = !SignatureValidate(signer, verifier);
<a name="l00748"></a>00748         pass = pass &amp;&amp; !fail;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         fail = !verifier.VerifyMessage((byte *)plain, strlen(plain), signature, verifier.SignatureLength());
<a name="l00751"></a>00751         pass = pass &amp;&amp; !fail;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED    &quot;</span> : <span class="stringliteral">&quot;passed    &quot;</span>);
<a name="l00754"></a>00754         cout &lt;&lt; <span class="stringliteral">&quot;verification check against test vector\n&quot;</span>;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         cout &lt;&lt; <span class="stringliteral">&quot;Generating signature key from seed...&quot;</span> &lt;&lt; endl;
<a name="l00757"></a>00757         signer.AccessKey().GenerateRandom(GlobalRNG(), MakeParameters(<span class="stringliteral">&quot;Seed&quot;</span>, <a class="code" href="class_const_byte_array_parameter.html" title="used to pass byte array input as part of a NameValuePairs object">ConstByteArrayParameter</a>((<span class="keyword">const</span> byte *)<span class="stringliteral">&quot;test&quot;</span>, 4))(<span class="stringliteral">&quot;KeySize&quot;</span>, 3*512));
<a name="l00758"></a>00758         verifier = signer;
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         fail = !SignatureValidate(signer, verifier);
<a name="l00761"></a>00761         pass = pass &amp;&amp; !fail;
<a name="l00762"></a>00762 
<a name="l00763"></a>00763         <span class="keywordflow">return</span> pass;
<a name="l00764"></a>00764 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 9 2010 15:56:38 for Crypto++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
