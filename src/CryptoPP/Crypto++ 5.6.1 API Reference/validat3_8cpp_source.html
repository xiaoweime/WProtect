<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Crypto++: validat3.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>validat3.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// validat3.cpp - written and placed in the public domain by Wei Dai</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &quot;pch.h&quot;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;validate.h&quot;</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor">#include &quot;smartptr.h&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;crc.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;adler32.h&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;md2.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;md4.h&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;md5.h&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;sha.h&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;tiger.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;ripemd.h&quot;</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;hmac.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;ttmac.h&quot;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="integer_8h.html">integer.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;pwdbased.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="filters_8h.html">filters.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;hex.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;files.h&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 USING_NAMESPACE(CryptoPP)
<a name="l00030"></a>00030 USING_NAMESPACE(std)
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="struct_hash_test_tuple.html">00032</a> struct <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>
<a name="l00033"></a>00033 {
<a name="l00034"></a>00034         HashTestTuple(<span class="keyword">const</span> <span class="keywordtype">char</span> *input, <span class="keyword">const</span> <span class="keywordtype">char</span> *output, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> repeatTimes=1)
<a name="l00035"></a>00035                 : input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}
<a name="l00036"></a>00036         
<a name="l00037"></a>00037         HashTestTuple(<span class="keyword">const</span> <span class="keywordtype">char</span> *input, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inputLen, <span class="keyword">const</span> <span class="keywordtype">char</span> *output, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> repeatTimes)
<a name="l00038"></a>00038                 : input((byte *)input), output((byte *)output), inputLen(inputLen), repeatTimes(repeatTimes) {}
<a name="l00039"></a>00039 
<a name="l00040"></a>00040         <span class="keyword">const</span> byte *input, *output;
<a name="l00041"></a>00041         <span class="keywordtype">size_t</span> inputLen;
<a name="l00042"></a>00042         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> repeatTimes;
<a name="l00043"></a>00043 };
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keywordtype">bool</span> HashModuleTest(<a class="code" href="class_hash_transformation.html" title="interface for hash functions and data processing part of MACs">HashTransformation</a> &amp;md, <span class="keyword">const</span> <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> *testSet, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> testSetSize)
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00048"></a>00048         <a class="code" href="class_sec_block.html">SecByteBlock</a> digest(md.<a class="code" href="class_hash_transformation.html#a9f42cc280bac76b884ad12615c0dabb5" title="size of the hash/digest/MAC returned by Final()">DigestSize</a>());
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;testSetSize; i++)
<a name="l00051"></a>00051         {
<a name="l00052"></a>00052                 <span class="keywordtype">unsigned</span> j;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054                 <span class="keywordflow">for</span> (j=0; j&lt;testSet[i].repeatTimes; j++)
<a name="l00055"></a>00055                         md.<a class="code" href="class_hash_transformation.html#aafabefaf445b65d3ba0d8e1c0294afe5" title="process more input">Update</a>(testSet[i].input, testSet[i].inputLen);
<a name="l00056"></a>00056                 md.<a class="code" href="class_hash_transformation.html#aa0b8c7a110d8968268fd02ec32b9a8e8" title="compute hash for current message, then restart for a new message">Final</a>(digest);
<a name="l00057"></a>00057                 fail = memcmp(digest, testSet[i].output, md.<a class="code" href="class_hash_transformation.html#a9f42cc280bac76b884ad12615c0dabb5" title="size of the hash/digest/MAC returned by Final()">DigestSize</a>()) != 0;
<a name="l00058"></a>00058                 pass = pass &amp;&amp; !fail;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED   &quot;</span> : <span class="stringliteral">&quot;passed   &quot;</span>);
<a name="l00061"></a>00061                 <span class="keywordflow">for</span> (j=0; j&lt;md.<a class="code" href="class_hash_transformation.html#a9f42cc280bac76b884ad12615c0dabb5" title="size of the hash/digest/MAC returned by Final()">DigestSize</a>(); j++)
<a name="l00062"></a>00062                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)digest[j];
<a name="l00063"></a>00063                 cout &lt;&lt; <span class="stringliteral">&quot;   \&quot;&quot;</span> &lt;&lt; (<span class="keywordtype">char</span> *)testSet[i].input &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span>;
<a name="l00064"></a>00064                 <span class="keywordflow">if</span> (testSet[i].repeatTimes != 1)
<a name="l00065"></a>00065                         cout &lt;&lt; <span class="stringliteral">&quot; repeated &quot;</span> &lt;&lt; dec &lt;&lt; testSet[i].repeatTimes &lt;&lt; <span class="stringliteral">&quot; times&quot;</span>;
<a name="l00066"></a>00066                 cout  &lt;&lt; endl;
<a name="l00067"></a>00067         }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         <span class="keywordflow">return</span> pass;
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keywordtype">bool</span> ValidateCRC32()
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00075"></a>00075         {
<a name="l00076"></a>00076                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x00\x00\x00\x00&quot;</span>),
<a name="l00077"></a>00077                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\x43\xbe\xb7\xe8&quot;</span>),
<a name="l00078"></a>00078                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\xc2\x41\x24\x35&quot;</span>),
<a name="l00079"></a>00079                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\x7f\x9d\x15\x20&quot;</span>),
<a name="l00080"></a>00080                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\xbd\x50\x27\x4c&quot;</span>),
<a name="l00081"></a>00081                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\xd2\xe6\xc2\x1f&quot;</span>),
<a name="l00082"></a>00082                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\x72\x4a\xa9\x7c&quot;</span>),
<a name="l00083"></a>00083                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;123456789&quot;</span>, <span class="stringliteral">&quot;\x26\x39\xf4\xcb&quot;</span>)
<a name="l00084"></a>00084         };
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         <a class="code" href="class_c_r_c32.html" title="CRC Checksum Calculation.">CRC32</a> crc;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         cout &lt;&lt; <span class="stringliteral">&quot;\nCRC-32 validation suite running...\n\n&quot;</span>;
<a name="l00089"></a>00089         <span class="keywordflow">return</span> HashModuleTest(crc, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00090"></a>00090 }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="keywordtype">bool</span> ValidateAdler32()
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00095"></a>00095         {
<a name="l00096"></a>00096                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x00\x00\x00\x01&quot;</span>),
<a name="l00097"></a>00097                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\x00\x62\x00\x62&quot;</span>),
<a name="l00098"></a>00098                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\x02\x4d\x01\x27&quot;</span>),
<a name="l00099"></a>00099                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\x29\x75\x05\x86&quot;</span>),
<a name="l00100"></a>00100                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\x90\x86\x0b\x20&quot;</span>),
<a name="l00101"></a>00101                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\x8a\xdb\x15\x0c&quot;</span>),
<a name="l00102"></a>00102                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>, <span class="stringliteral">&quot;\x15\xd8\x70\xf9&quot;</span>, 15625)
<a name="l00103"></a>00103         };
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <a class="code" href="class_adler32.html" title="ADLER-32 checksum calculations.">Adler32</a> md;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         cout &lt;&lt; <span class="stringliteral">&quot;\nAdler-32 validation suite running...\n\n&quot;</span>;
<a name="l00108"></a>00108         <span class="keywordflow">return</span> HashModuleTest(md, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="keywordtype">bool</span> ValidateMD2()
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00114"></a>00114         {
<a name="l00115"></a>00115                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x83\x50\xe5\xa3\xe2\x4c\x15\x3d\xf2\x27\x5c\x9f\x80\x69\x27\x73&quot;</span>),
<a name="l00116"></a>00116                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\x32\xec\x01\xec\x4a\x6d\xac\x72\xc0\xab\x96\xfb\x34\xc0\xb5\xd1&quot;</span>),
<a name="l00117"></a>00117                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\xda\x85\x3b\x0d\x3f\x88\xd9\x9b\x30\x28\x3a\x69\xe6\xde\xd6\xbb&quot;</span>),
<a name="l00118"></a>00118                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\xab\x4f\x49\x6b\xfb\x2a\x53\x0b\x21\x9f\xf3\x30\x31\xfe\x06\xb0&quot;</span>),
<a name="l00119"></a>00119                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\x4e\x8d\xdf\xf3\x65\x02\x92\xab\x5a\x41\x08\xc3\xaa\x47\x94\x0b&quot;</span>),
<a name="l00120"></a>00120                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\xda\x33\xde\xf2\xa4\x2d\xf1\x39\x75\x35\x28\x46\xc3\x03\x38\xcd&quot;</span>),
<a name="l00121"></a>00121                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\xd5\x97\x6f\x79\xd8\x3d\x3a\x0d\xc9\x80\x6c\x3c\x66\xf3\xef\xd8&quot;</span>)
<a name="l00122"></a>00122         };
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         Weak::MD2 md2;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         cout &lt;&lt; <span class="stringliteral">&quot;\nMD2 validation suite running...\n\n&quot;</span>;
<a name="l00127"></a>00127         <span class="keywordflow">return</span> HashModuleTest(md2, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00128"></a>00128 }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keywordtype">bool</span> ValidateMD4()
<a name="l00131"></a>00131 {
<a name="l00132"></a>00132         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00133"></a>00133         {
<a name="l00134"></a>00134                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x31\xd6\xcf\xe0\xd1\x6a\xe9\x31\xb7\x3c\x59\xd7\xe0\xc0\x89\xc0&quot;</span>),
<a name="l00135"></a>00135                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\xbd\xe5\x2c\xb3\x1d\xe3\x3e\x46\x24\x5e\x05\xfb\xdb\xd6\xfb\x24&quot;</span>),
<a name="l00136"></a>00136                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\xa4\x48\x01\x7a\xaf\x21\xd8\x52\x5f\xc1\x0a\xe8\x7a\xa6\x72\x9d&quot;</span>),
<a name="l00137"></a>00137                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\xd9\x13\x0a\x81\x64\x54\x9f\xe8\x18\x87\x48\x06\xe1\xc7\x01\x4b&quot;</span>),
<a name="l00138"></a>00138                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\xd7\x9e\x1c\x30\x8a\xa5\xbb\xcd\xee\xa8\xed\x63\xdf\x41\x2d\xa9&quot;</span>),
<a name="l00139"></a>00139                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\x04\x3f\x85\x82\xf2\x41\xdb\x35\x1c\xe6\x27\xe1\x53\xe7\xf0\xe4&quot;</span>),
<a name="l00140"></a>00140                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\xe3\x3b\x4d\xdc\x9c\x38\xf2\x19\x9c\x3e\x7b\x16\x4f\xcc\x05\x36&quot;</span>)
<a name="l00141"></a>00141         };
<a name="l00142"></a>00142 
<a name="l00143"></a>00143         Weak::MD4 md4;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         cout &lt;&lt; <span class="stringliteral">&quot;\nMD4 validation suite running...\n\n&quot;</span>;
<a name="l00146"></a>00146         <span class="keywordflow">return</span> HashModuleTest(md4, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keywordtype">bool</span> ValidateMD5()
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00152"></a>00152         {
<a name="l00153"></a>00153                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\xd4\x1d\x8c\xd9\x8f\x00\xb2\x04\xe9\x80\x09\x98\xec\xf8\x42\x7e&quot;</span>),
<a name="l00154"></a>00154                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\x0c\xc1\x75\xb9\xc0\xf1\xb6\xa8\x31\xc3\x99\xe2\x69\x77\x26\x61&quot;</span>),
<a name="l00155"></a>00155                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\x90\x01\x50\x98\x3c\xd2\x4f\xb0\xd6\x96\x3f\x7d\x28\xe1\x7f\x72&quot;</span>),
<a name="l00156"></a>00156                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\xf9\x6b\x69\x7d\x7c\xb7\x93\x8d\x52\x5a\x2f\x31\xaa\xf1\x61\xd0&quot;</span>),
<a name="l00157"></a>00157                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\xc3\xfc\xd3\xd7\x61\x92\xe4\x00\x7d\xfb\x49\x6c\xca\x67\xe1\x3b&quot;</span>),
<a name="l00158"></a>00158                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\xd1\x74\xab\x98\xd2\x77\xd9\xf5\xa5\x61\x1c\x2c\x9f\x41\x9d\x9f&quot;</span>),
<a name="l00159"></a>00159                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\x57\xed\xf4\xa2\x2b\xe3\xc9\x55\xac\x49\xda\x2e\x21\x07\xb6\x7a&quot;</span>)
<a name="l00160"></a>00160         };
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         Weak::MD5 md5;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         cout &lt;&lt; <span class="stringliteral">&quot;\nMD5 validation suite running...\n\n&quot;</span>;
<a name="l00165"></a>00165         <span class="keywordflow">return</span> HashModuleTest(md5, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="keywordtype">bool</span> ValidateSHA()
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170         cout &lt;&lt; <span class="stringliteral">&quot;\nSHA validation suite running...\n\n&quot;</span>;
<a name="l00171"></a>00171         <span class="keywordflow">return</span> RunTestDataFile(<span class="stringliteral">&quot;TestVectors/sha.txt&quot;</span>);
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="keywordtype">bool</span> ValidateSHA2()
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176         cout &lt;&lt; <span class="stringliteral">&quot;\nSHA validation suite running...\n\n&quot;</span>;
<a name="l00177"></a>00177         <span class="keywordflow">return</span> RunTestDataFile(<span class="stringliteral">&quot;TestVectors/sha.txt&quot;</span>);
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="keywordtype">bool</span> ValidateTiger()
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182         cout &lt;&lt; <span class="stringliteral">&quot;\nTiger validation suite running...\n\n&quot;</span>;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] =
<a name="l00185"></a>00185         {
<a name="l00186"></a>00186                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x32\x93\xac\x63\x0c\x13\xf0\x24\x5f\x92\xbb\xb1\x76\x6e\x16\x16\x7a\x4e\x58\x49\x2d\xde\x73\xf3&quot;</span>),
<a name="l00187"></a>00187                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\x2a\xab\x14\x84\xe8\xc1\x58\xf2\xbf\xb8\xc5\xff\x41\xb5\x7a\x52\x51\x29\x13\x1c\x95\x7b\x5f\x93&quot;</span>),
<a name="l00188"></a>00188                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;Tiger&quot;</span>, <span class="stringliteral">&quot;\xdd\x00\x23\x07\x99\xf5\x00\x9f\xec\x6d\xeb\xc8\x38\xbb\x6a\x27\xdf\x2b\x9d\x6f\x11\x0c\x79\x37&quot;</span>),
<a name="l00189"></a>00189                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-&quot;</span>, <span class="stringliteral">&quot;\xf7\x1c\x85\x83\x90\x2a\xfb\x87\x9e\xdf\xe6\x10\xf8\x2c\x0d\x47\x86\xa3\xa5\x34\x50\x44\x86\xb5&quot;</span>),
<a name="l00190"></a>00190                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ=abcdefghijklmnopqrstuvwxyz+0123456789&quot;</span>, <span class="stringliteral">&quot;\x48\xce\xeb\x63\x08\xb8\x7d\x46\xe9\x5d\x65\x61\x12\xcd\xf1\x8d\x97\x91\x5f\x97\x65\x65\x89\x57&quot;</span>),
<a name="l00191"></a>00191                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham&quot;</span>, <span class="stringliteral">&quot;\x8a\x86\x68\x29\x04\x0a\x41\x0c\x72\x9a\xd2\x3f\x5a\xda\x71\x16\x03\xb3\xcd\xd3\x57\xe4\xc1\x5e&quot;</span>),
<a name="l00192"></a>00192                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge.&quot;</span>, <span class="stringliteral">&quot;\xce\x55\xa6\xaf\xd5\x91\xf5\xeb\xac\x54\x7f\xf8\x4f\x89\x22\x7f\x93\x31\xda\xb0\xb6\x11\xc8\x89&quot;</span>),
<a name="l00193"></a>00193                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge, 1996.&quot;</span>, <span class="stringliteral">&quot;\x63\x1a\xbd\xd1\x03\xeb\x9a\x3d\x24\x5b\x6d\xfd\x4d\x77\xb2\x57\xfc\x74\x39\x50\x1d\x15\x68\xdd&quot;</span>),
<a name="l00194"></a>00194                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-&quot;</span>, <span class="stringliteral">&quot;\xc5\x40\x34\xe5\xb4\x3e\xb8\x00\x58\x48\xa7\xe0\xae\x6a\xac\x76\xe4\xff\x59\x0a\xe7\x15\xfd\x25&quot;</span>)
<a name="l00195"></a>00195         };
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         <a class="code" href="class_tiger.html" title="Tiger">Tiger</a> tiger;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         <span class="keywordflow">return</span> HashModuleTest(tiger, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0]));
<a name="l00200"></a>00200 }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keywordtype">bool</span> ValidateRIPEMD()
<a name="l00203"></a>00203 {
<a name="l00204"></a>00204         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet128[] = 
<a name="l00205"></a>00205         {
<a name="l00206"></a>00206                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\xcd\xf2\x62\x13\xa1\x50\xdc\x3e\xcb\x61\x0f\x18\xf6\xb3\x8b\x46&quot;</span>),
<a name="l00207"></a>00207                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\x86\xbe\x7a\xfa\x33\x9d\x0f\xc7\xcf\xc7\x85\xe7\x2f\x57\x8d\x33&quot;</span>),
<a name="l00208"></a>00208                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\xc1\x4a\x12\x19\x9c\x66\xe4\xba\x84\x63\x6b\x0f\x69\x14\x4c\x77&quot;</span>),
<a name="l00209"></a>00209                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\x9e\x32\x7b\x3d\x6e\x52\x30\x62\xaf\xc1\x13\x2d\x7d\xf9\xd1\xb8&quot;</span>),
<a name="l00210"></a>00210                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\xfd\x2a\xa6\x07\xf7\x1d\xc8\xf5\x10\x71\x49\x22\xb3\x71\x83\x4e&quot;</span>),
<a name="l00211"></a>00211                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq&quot;</span>, <span class="stringliteral">&quot;\xa1\xaa\x06\x89\xd0\xfa\xfa\x2d\xdc\x22\xe8\x8b\x49\x13\x3a\x06&quot;</span>),
<a name="l00212"></a>00212                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\xd1\xe9\x59\xeb\x17\x9c\x91\x1f\xae\xa4\x62\x4c\x60\xc5\xc7\x02&quot;</span>),
<a name="l00213"></a>00213                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\x3f\x45\xef\x19\x47\x32\xc2\xdb\xb2\xc4\xa2\xc7\x69\x79\x5f\xa3&quot;</span>),
<a name="l00214"></a>00214                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>, <span class="stringliteral">&quot;\x4a\x7f\x57\x23\xf9\x54\xeb\xa1\x21\x6c\x9d\x8f\x63\x20\x43\x1f&quot;</span>, 15625)
<a name="l00215"></a>00215         };
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet160[] = 
<a name="l00218"></a>00218         {
<a name="l00219"></a>00219                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x9c\x11\x85\xa5\xc5\xe9\xfc\x54\x61\x28\x08\x97\x7e\xe8\xf5\x48\xb2\x25\x8d\x31&quot;</span>),
<a name="l00220"></a>00220                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\x0b\xdc\x9d\x2d\x25\x6b\x3e\xe9\xda\xae\x34\x7b\xe6\xf4\xdc\x83\x5a\x46\x7f\xfe&quot;</span>),
<a name="l00221"></a>00221                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\x8e\xb2\x08\xf7\xe0\x5d\x98\x7a\x9b\x04\x4a\x8e\x98\xc6\xb0\x87\xf1\x5a\x0b\xfc&quot;</span>),
<a name="l00222"></a>00222                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\x5d\x06\x89\xef\x49\xd2\xfa\xe5\x72\xb8\x81\xb1\x23\xa8\x5f\xfa\x21\x59\x5f\x36&quot;</span>),
<a name="l00223"></a>00223                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\xf7\x1c\x27\x10\x9c\x69\x2c\x1b\x56\xbb\xdc\xeb\x5b\x9d\x28\x65\xb3\x70\x8d\xbc&quot;</span>),
<a name="l00224"></a>00224                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq&quot;</span>, <span class="stringliteral">&quot;\x12\xa0\x53\x38\x4a\x9c\x0c\x88\xe4\x05\xa0\x6c\x27\xdc\xf4\x9a\xda\x62\xeb\x2b&quot;</span>),
<a name="l00225"></a>00225                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\xb0\xe2\x0b\x6e\x31\x16\x64\x02\x86\xed\x3a\x87\xa5\x71\x30\x79\xb2\x1f\x51\x89&quot;</span>),
<a name="l00226"></a>00226                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\x9b\x75\x2e\x45\x57\x3d\x4b\x39\xf4\xdb\xd3\x32\x3c\xab\x82\xbf\x63\x32\x6b\xfb&quot;</span>),
<a name="l00227"></a>00227                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>, <span class="stringliteral">&quot;\x52\x78\x32\x43\xc1\x69\x7b\xdb\xe1\x6d\x37\xf9\x7f\x68\xf0\x83\x25\xdc\x15\x28&quot;</span>, 15625)
<a name="l00228"></a>00228         };
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet256[] = 
<a name="l00231"></a>00231         {
<a name="l00232"></a>00232                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x02\xba\x4c\x4e\x5f\x8e\xcd\x18\x77\xfc\x52\xd6\x4d\x30\xe3\x7a\x2d\x97\x74\xfb\x1e\x5d\x02\x63\x80\xae\x01\x68\xe3\xc5\x52\x2d&quot;</span>),
<a name="l00233"></a>00233                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\xf9\x33\x3e\x45\xd8\x57\xf5\xd9\x0a\x91\xba\xb7\x0a\x1e\xba\x0c\xfb\x1b\xe4\xb0\x78\x3c\x9a\xcf\xcd\x88\x3a\x91\x34\x69\x29\x25&quot;</span>),
<a name="l00234"></a>00234                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\xaf\xbd\x6e\x22\x8b\x9d\x8c\xbb\xce\xf5\xca\x2d\x03\xe6\xdb\xa1\x0a\xc0\xbc\x7d\xcb\xe4\x68\x0e\x1e\x42\xd2\xe9\x75\x45\x9b\x65&quot;</span>),
<a name="l00235"></a>00235                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\x87\xe9\x71\x75\x9a\x1c\xe4\x7a\x51\x4d\x5c\x91\x4c\x39\x2c\x90\x18\xc7\xc4\x6b\xc1\x44\x65\x55\x4a\xfc\xdf\x54\xa5\x07\x0c\x0e&quot;</span>),
<a name="l00236"></a>00236                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\x64\x9d\x30\x34\x75\x1e\xa2\x16\x77\x6b\xf9\xa1\x8a\xcc\x81\xbc\x78\x96\x11\x8a\x51\x97\x96\x87\x82\xdd\x1f\xd9\x7d\x8d\x51\x33&quot;</span>),
<a name="l00237"></a>00237                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq&quot;</span>, <span class="stringliteral">&quot;\x38\x43\x04\x55\x83\xaa\xc6\xc8\xc8\xd9\x12\x85\x73\xe7\xa9\x80\x9a\xfb\x2a\x0f\x34\xcc\xc3\x6e\xa9\xe7\x2f\x16\xf6\x36\x8e\x3f&quot;</span>),
<a name="l00238"></a>00238                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\x57\x40\xa4\x08\xac\x16\xb7\x20\xb8\x44\x24\xae\x93\x1c\xbb\x1f\xe3\x63\xd1\xd0\xbf\x40\x17\xf1\xa8\x9f\x7e\xa6\xde\x77\xa0\xb8&quot;</span>),
<a name="l00239"></a>00239                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\x06\xfd\xcc\x7a\x40\x95\x48\xaa\xf9\x13\x68\xc0\x6a\x62\x75\xb5\x53\xe3\xf0\x99\xbf\x0e\xa4\xed\xfd\x67\x78\xdf\x89\xa8\x90\xdd&quot;</span>),
<a name="l00240"></a>00240                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>, <span class="stringliteral">&quot;\xac\x95\x37\x44\xe1\x0e\x31\x51\x4c\x15\x0d\x4d\x8d\x7b\x67\x73\x42\xe3\x33\x99\x78\x82\x96\xe4\x3a\xe4\x85\x0c\xe4\xf9\x79\x78&quot;</span>, 15625)
<a name="l00241"></a>00241         };
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet320[] = 
<a name="l00244"></a>00244         {
<a name="l00245"></a>00245                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\x22\xd6\x5d\x56\x61\x53\x6c\xdc\x75\xc1\xfd\xf5\xc6\xde\x7b\x41\xb9\xf2\x73\x25\xeb\xc6\x1e\x85\x57\x17\x7d\x70\x5a\x0e\xc8\x80\x15\x1c\x3a\x32\xa0\x08\x99\xb8&quot;</span>),
<a name="l00246"></a>00246                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\xce\x78\x85\x06\x38\xf9\x26\x58\xa5\xa5\x85\x09\x75\x79\x92\x6d\xda\x66\x7a\x57\x16\x56\x2c\xfc\xf6\xfb\xe7\x7f\x63\x54\x2f\x99\xb0\x47\x05\xd6\x97\x0d\xff\x5d&quot;</span>),
<a name="l00247"></a>00247                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abc&quot;</span>, <span class="stringliteral">&quot;\xde\x4c\x01\xb3\x05\x4f\x89\x30\xa7\x9d\x09\xae\x73\x8e\x92\x30\x1e\x5a\x17\x08\x5b\xef\xfd\xc1\xb8\xd1\x16\x71\x3e\x74\xf8\x2f\xa9\x42\xd6\x4c\xdb\xc4\x68\x2d&quot;</span>),
<a name="l00248"></a>00248                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;message digest&quot;</span>, <span class="stringliteral">&quot;\x3a\x8e\x28\x50\x2e\xd4\x5d\x42\x2f\x68\x84\x4f\x9d\xd3\x16\xe7\xb9\x85\x33\xfa\x3f\x2a\x91\xd2\x9f\x84\xd4\x25\xc8\x8d\x6b\x4e\xff\x72\x7d\xf6\x6a\x7c\x01\x97&quot;</span>),
<a name="l00249"></a>00249                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\xca\xbd\xb1\x81\x0b\x92\x47\x0a\x20\x93\xaa\x6b\xce\x05\x95\x2c\x28\x34\x8c\xf4\x3f\xf6\x08\x41\x97\x51\x66\xbb\x40\xed\x23\x40\x04\xb8\x82\x44\x63\xe6\xb0\x09&quot;</span>),
<a name="l00250"></a>00250                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq&quot;</span>, <span class="stringliteral">&quot;\xd0\x34\xa7\x95\x0c\xf7\x22\x02\x1b\xa4\xb8\x4d\xf7\x69\xa5\xde\x20\x60\xe2\x59\xdf\x4c\x9b\xb4\xa4\x26\x8c\x0e\x93\x5b\xbc\x74\x70\xa9\x69\xc9\xd0\x72\xa1\xac&quot;</span>),
<a name="l00251"></a>00251                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\xed\x54\x49\x40\xc8\x6d\x67\xf2\x50\xd2\x32\xc3\x0b\x7b\x3e\x57\x70\xe0\xc6\x0c\x8c\xb9\xa4\xca\xfe\x3b\x11\x38\x8a\xf9\x92\x0e\x1b\x99\x23\x0b\x84\x3c\x86\xa4&quot;</span>),
<a name="l00252"></a>00252                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>, <span class="stringliteral">&quot;\x55\x78\x88\xaf\x5f\x6d\x8e\xd6\x2a\xb6\x69\x45\xc6\xd2\xa0\xa4\x7e\xcd\x53\x41\xe9\x15\xeb\x8f\xea\x1d\x05\x24\x95\x5f\x82\x5d\xc7\x17\xe4\xa0\x08\xab\x2d\x42&quot;</span>),
<a name="l00253"></a>00253                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>, <span class="stringliteral">&quot;\xbd\xee\x37\xf4\x37\x1e\x20\x64\x6b\x8b\x0d\x86\x2d\xda\x16\x29\x2a\xe3\x6f\x40\x96\x5e\x8c\x85\x09\xe6\x3d\x1d\xbd\xde\xcc\x50\x3e\x2b\x63\xeb\x92\x45\xbb\x66&quot;</span>, 15625)
<a name="l00254"></a>00254         };
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         cout &lt;&lt; <span class="stringliteral">&quot;\nRIPEMD-128 validation suite running...\n\n&quot;</span>;
<a name="l00259"></a>00259         <a class="code" href="class_r_i_p_e_m_d128.html">RIPEMD128</a> md128;
<a name="l00260"></a>00260         pass = HashModuleTest(md128, testSet128, <span class="keyword">sizeof</span>(testSet128)/<span class="keyword">sizeof</span>(testSet128[0])) &amp;&amp; pass;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         cout &lt;&lt; <span class="stringliteral">&quot;\nRIPEMD-160 validation suite running...\n\n&quot;</span>;
<a name="l00263"></a>00263         <a class="code" href="class_r_i_p_e_m_d160.html" title="RIPEMD-160">RIPEMD160</a> md160;
<a name="l00264"></a>00264         pass = HashModuleTest(md160, testSet160, <span class="keyword">sizeof</span>(testSet160)/<span class="keyword">sizeof</span>(testSet160[0])) &amp;&amp; pass;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266         cout &lt;&lt; <span class="stringliteral">&quot;\nRIPEMD-256 validation suite running...\n\n&quot;</span>;
<a name="l00267"></a>00267         <a class="code" href="class_r_i_p_e_m_d256.html">RIPEMD256</a> md256;
<a name="l00268"></a>00268         pass = HashModuleTest(md256, testSet256, <span class="keyword">sizeof</span>(testSet256)/<span class="keyword">sizeof</span>(testSet256[0])) &amp;&amp; pass;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         cout &lt;&lt; <span class="stringliteral">&quot;\nRIPEMD-320 validation suite running...\n\n&quot;</span>;
<a name="l00271"></a>00271         <a class="code" href="class_r_i_p_e_m_d320.html">RIPEMD320</a> md320;
<a name="l00272"></a>00272         pass = HashModuleTest(md320, testSet320, <span class="keyword">sizeof</span>(testSet320)/<span class="keyword">sizeof</span>(testSet320[0])) &amp;&amp; pass;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         <span class="keywordflow">return</span> pass;
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="preprocessor">#ifdef CRYPTOPP_REMOVED</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span><span class="keywordtype">bool</span> ValidateHAVAL()
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280         <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a> testSet[] = 
<a name="l00281"></a>00281         {
<a name="l00282"></a>00282                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;\xC6\x8F\x39\x91\x3F\x90\x1F\x3D\xDF\x44\xC7\x07\x35\x7A\x7D\x70&quot;</span>),
<a name="l00283"></a>00283                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;\x4D\xA0\x8F\x51\x4A\x72\x75\xDB\xC4\xCE\xCE\x4A\x34\x73\x85\x98\x39\x83\xA8\x30&quot;</span>),
<a name="l00284"></a>00284                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;HAVAL&quot;</span>, <span class="stringliteral">&quot;\x0C\x13\x96\xD7\x77\x26\x89\xC4\x67\x73\xF3\xDA\xAC\xA4\xEF\xA9\x82\xAD\xBF\xB2\xF1\x46\x7E\xEA&quot;</span>),
<a name="l00285"></a>00285                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;0123456789&quot;</span>, <span class="stringliteral">&quot;\xBE\xBD\x78\x16\xF0\x9B\xAE\xEC\xF8\x90\x3B\x1B\x9B\xC6\x72\xD9\xFA\x42\x8E\x46\x2B\xA6\x99\xF8\x14\x84\x15\x29&quot;</span>),
<a name="l00286"></a>00286                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="stringliteral">&quot;\xC9\xC7\xD8\xAF\xA1\x59\xFD\x9E\x96\x5C\xB8\x3F\xF5\xEE\x6F\x58\xAE\xDA\x35\x2C\x0E\xFF\x00\x55\x48\x15\x3A\x61\x55\x1C\x38\xEE&quot;</span>),
<a name="l00287"></a>00287                 <a class="code" href="struct_hash_test_tuple.html">HashTestTuple</a>(<span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>, <span class="stringliteral">&quot;\xB4\x5C\xB6\xE6\x2F\x2B\x13\x20\xE4\xF8\xF1\xB0\xB2\x73\xD4\x5A\xDD\x47\xC3\x21\xFD\x23\x99\x9D\xCF\x40\x3A\xC3\x76\x36\xD9\x63&quot;</span>)
<a name="l00288"></a>00288         };
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         cout &lt;&lt; <span class="stringliteral">&quot;\nHAVAL validation suite running...\n\n&quot;</span>;
<a name="l00293"></a>00293         {
<a name="l00294"></a>00294                 HAVAL3 md(16);
<a name="l00295"></a>00295                 pass = HashModuleTest(md, testSet+0, 1) &amp;&amp; pass;
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297         {
<a name="l00298"></a>00298                 HAVAL3 md(20);
<a name="l00299"></a>00299                 pass = HashModuleTest(md, testSet+1, 1) &amp;&amp; pass;
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301         {
<a name="l00302"></a>00302                 HAVAL4 md(24);
<a name="l00303"></a>00303                 pass = HashModuleTest(md, testSet+2, 1) &amp;&amp; pass;
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305         {
<a name="l00306"></a>00306                 HAVAL4 md(28);
<a name="l00307"></a>00307                 pass = HashModuleTest(md, testSet+3, 1) &amp;&amp; pass;
<a name="l00308"></a>00308         }
<a name="l00309"></a>00309         {
<a name="l00310"></a>00310                 HAVAL5 md(32);
<a name="l00311"></a>00311                 pass = HashModuleTest(md, testSet+4, 1) &amp;&amp; pass;
<a name="l00312"></a>00312         }
<a name="l00313"></a>00313         {
<a name="l00314"></a>00314                 HAVAL5 md(32);
<a name="l00315"></a>00315                 pass = HashModuleTest(md, testSet+5, 1) &amp;&amp; pass;
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318         <span class="keywordflow">return</span> pass;
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 <span class="preprocessor">#endif</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span>
<a name="l00322"></a>00322 <span class="keywordtype">bool</span> ValidatePanama()
<a name="l00323"></a>00323 {
<a name="l00324"></a>00324         <span class="keywordflow">return</span> RunTestDataFile(<span class="stringliteral">&quot;TestVectors/panama.txt&quot;</span>);
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="keywordtype">bool</span> ValidateWhirlpool()
<a name="l00328"></a>00328 {
<a name="l00329"></a>00329         <span class="keywordflow">return</span> RunTestDataFile(<span class="stringliteral">&quot;TestVectors/whrlpool.txt&quot;</span>);
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="preprocessor">#ifdef CRYPTOPP_REMOVED</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span><span class="keywordtype">bool</span> ValidateMD5MAC()
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335         <span class="keyword">const</span> byte keys[2][MD5MAC::KEYLENGTH]={
<a name="l00336"></a>00336                 {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff},
<a name="l00337"></a>00337                 {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}};
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         <span class="keyword">const</span> <span class="keywordtype">char</span> *TestVals[7]={
<a name="l00340"></a>00340                 <span class="stringliteral">&quot;&quot;</span>,
<a name="l00341"></a>00341                 <span class="stringliteral">&quot;a&quot;</span>,
<a name="l00342"></a>00342                 <span class="stringliteral">&quot;abc&quot;</span>,
<a name="l00343"></a>00343                 <span class="stringliteral">&quot;message digest&quot;</span>,
<a name="l00344"></a>00344                 <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>,
<a name="l00345"></a>00345                 <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>,
<a name="l00346"></a>00346                 <span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>};
<a name="l00347"></a>00347 
<a name="l00348"></a>00348         <span class="keyword">const</span> byte output[2][7][MD5MAC::DIGESTSIZE]={
<a name="l00349"></a>00349                 {{0x1f,0x1e,0xf2,0x37,0x5c,0xc0,0xe0,0x84,0x4f,0x98,0xe7,0xe8,0x11,0xa3,0x4d,0xa8},
<a name="l00350"></a>00350                 {0x7a,0x76,0xee,0x64,0xca,0x71,0xef,0x23,0x7e,0x26,0x29,0xed,0x94,0x52,0x73,0x65},
<a name="l00351"></a>00351                 {0xe8,0x01,0x3c,0x11,0xf7,0x20,0x9d,0x13,0x28,0xc0,0xca,0xa0,0x4f,0xd0,0x12,0xa6},
<a name="l00352"></a>00352                 {0xc8,0x95,0x53,0x4f,0x22,0xa1,0x74,0xbc,0x3e,0x6a,0x25,0xa2,0xb2,0xef,0xd6,0x30},
<a name="l00353"></a>00353                 {0x91,0x72,0x86,0x7e,0xb6,0x00,0x17,0x88,0x4c,0x6f,0xa8,0xcc,0x88,0xeb,0xe7,0xc9},
<a name="l00354"></a>00354                 {0x3b,0xd0,0xe1,0x1d,0x5e,0x09,0x4c,0xb7,0x1e,0x35,0x44,0xac,0xa9,0xb8,0xbf,0xa2},
<a name="l00355"></a>00355                 {0x93,0x37,0x16,0x64,0x44,0xcc,0x95,0x35,0xb7,0xd5,0xb8,0x0f,0x91,0xe5,0x29,0xcb}},
<a name="l00356"></a>00356                 {{0x2f,0x6e,0x73,0x13,0xbf,0xbb,0xbf,0xcc,0x3a,0x2d,0xde,0x26,0x8b,0x59,0xcc,0x4d},
<a name="l00357"></a>00357                 {0x69,0xf6,0xca,0xff,0x40,0x25,0x36,0xd1,0x7a,0xe1,0x38,0x03,0x2c,0x0c,0x5f,0xfd},
<a name="l00358"></a>00358                 {0x56,0xd3,0x2b,0x6c,0x34,0x76,0x65,0xd9,0x74,0xd6,0xf7,0x5c,0x3f,0xc6,0xf0,0x40},
<a name="l00359"></a>00359                 {0xb8,0x02,0xb2,0x15,0x4e,0x59,0x8b,0x6f,0x87,0x60,0x56,0xc7,0x85,0x46,0x2c,0x0b},
<a name="l00360"></a>00360                 {0x5a,0xde,0xf4,0xbf,0xf8,0x04,0xbe,0x08,0x58,0x7e,0x94,0x41,0xcf,0x6d,0xbd,0x57},
<a name="l00361"></a>00361                 {0x18,0xe3,0x49,0xa5,0x24,0x44,0xb3,0x0e,0x5e,0xba,0x5a,0xdd,0xdc,0xd9,0xf1,0x8d},
<a name="l00362"></a>00362                 {0xf2,0xb9,0x06,0xa5,0xb8,0x4b,0x9b,0x4b,0xbe,0x95,0xed,0x32,0x56,0x4e,0xe7,0xeb}}};
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         byte digest[MD5MAC::DIGESTSIZE];
<a name="l00365"></a>00365         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         cout &lt;&lt; <span class="stringliteral">&quot;\nMD5MAC validation suite running...\n&quot;</span>;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;2; k++)
<a name="l00370"></a>00370         {
<a name="l00371"></a>00371                 MD5MAC mac(keys[k]);
<a name="l00372"></a>00372                 cout &lt;&lt; <span class="stringliteral">&quot;\nKEY: &quot;</span>;
<a name="l00373"></a>00373                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;MD5MAC::KEYLENGTH;j++)
<a name="l00374"></a>00374                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)keys[k][j];
<a name="l00375"></a>00375                 cout &lt;&lt; endl &lt;&lt; endl;
<a name="l00376"></a>00376                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;7;i++)
<a name="l00377"></a>00377                 {
<a name="l00378"></a>00378                         mac.Update((byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00379"></a>00379                         mac.Final(digest);
<a name="l00380"></a>00380                         fail = memcmp(digest, output[k][i], MD5MAC::DIGESTSIZE)
<a name="l00381"></a>00381                                  || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00382"></a>00382                         pass = pass &amp;&amp; !fail;
<a name="l00383"></a>00383                         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED   &quot;</span> : <span class="stringliteral">&quot;passed   &quot;</span>);
<a name="l00384"></a>00384                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;MD5MAC::DIGESTSIZE;j++)
<a name="l00385"></a>00385                                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)digest[j];
<a name="l00386"></a>00386                         cout &lt;&lt; <span class="stringliteral">&quot;   \&quot;&quot;</span> &lt;&lt; TestVals[i] &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span> &lt;&lt; endl;
<a name="l00387"></a>00387                 }
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="keywordflow">return</span> pass;
<a name="l00391"></a>00391 }
<a name="l00392"></a>00392 <span class="preprocessor">#endif</span>
<a name="l00393"></a>00393 <span class="preprocessor"></span>
<a name="l00394"></a>00394 <span class="keywordtype">bool</span> ValidateHMAC()
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396         <span class="keywordflow">return</span> RunTestDataFile(<span class="stringliteral">&quot;TestVectors/hmac.txt&quot;</span>);
<a name="l00397"></a>00397 }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="preprocessor">#ifdef CRYPTOPP_REMOVED</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span><span class="keywordtype">bool</span> ValidateXMACC()
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402         <span class="keyword">typedef</span> XMACC&lt;MD5&gt; XMACC_MD5;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         <span class="keyword">const</span> byte keys[2][XMACC_MD5::KEYLENGTH]={
<a name="l00405"></a>00405                 {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb},
<a name="l00406"></a>00406                 {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98}};
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         <span class="keyword">const</span> word32 counters[2]={0xccddeeff, 0x76543210};
<a name="l00409"></a>00409 
<a name="l00410"></a>00410         <span class="keyword">const</span> <span class="keywordtype">char</span> *TestVals[7]={
<a name="l00411"></a>00411                 <span class="stringliteral">&quot;&quot;</span>,
<a name="l00412"></a>00412                 <span class="stringliteral">&quot;a&quot;</span>,
<a name="l00413"></a>00413                 <span class="stringliteral">&quot;abc&quot;</span>,
<a name="l00414"></a>00414                 <span class="stringliteral">&quot;message digest&quot;</span>,
<a name="l00415"></a>00415                 <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>,
<a name="l00416"></a>00416                 <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>,
<a name="l00417"></a>00417                 <span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>};
<a name="l00418"></a>00418 
<a name="l00419"></a>00419         <span class="keyword">const</span> byte output[2][7][XMACC_MD5::DIGESTSIZE]={
<a name="l00420"></a>00420                 {{0xcc,0xdd,0xef,0x00,0xfa,0x89,0x54,0x92,0x86,0x32,0xda,0x2a,0x3f,0x29,0xc5,0x52,0xa0,0x0d,0x05,0x13},
<a name="l00421"></a>00421                 {0xcc,0xdd,0xef,0x01,0xae,0xdb,0x8b,0x7b,0x69,0x71,0xc7,0x91,0x71,0x48,0x9d,0x18,0xe7,0xdf,0x9d,0x5a},
<a name="l00422"></a>00422                 {0xcc,0xdd,0xef,0x02,0x5e,0x01,0x2e,0x2e,0x4b,0xc3,0x83,0x62,0xc2,0xf4,0xe6,0x18,0x1c,0x44,0xaf,0xca},
<a name="l00423"></a>00423                 {0xcc,0xdd,0xef,0x03,0x3e,0xa9,0xf1,0xe0,0x97,0x91,0xf8,0xe2,0xbe,0xe0,0xdf,0xf3,0x41,0x03,0xb3,0x5a},
<a name="l00424"></a>00424                 {0xcc,0xdd,0xef,0x04,0x2e,0x6a,0x8d,0xb9,0x72,0xe3,0xce,0x9f,0xf4,0x28,0x45,0xe7,0xbc,0x80,0xa9,0xc7},
<a name="l00425"></a>00425                 {0xcc,0xdd,0xef,0x05,0x1a,0xd5,0x40,0x78,0xfb,0x16,0x37,0xfc,0x7a,0x1d,0xce,0xb4,0x77,0x10,0xb2,0xa0},
<a name="l00426"></a>00426                 {0xcc,0xdd,0xef,0x06,0x13,0x2f,0x11,0x47,0xd7,0x1b,0xb5,0x52,0x36,0x51,0x26,0xb0,0x96,0xd7,0x60,0x81}},
<a name="l00427"></a>00427                 {{0x76,0x54,0x32,0x11,0xe9,0xcb,0x74,0x32,0x07,0x93,0xfe,0x01,0xdd,0x27,0xdb,0xde,0x6b,0x77,0xa4,0x56},
<a name="l00428"></a>00428                 {0x76,0x54,0x32,0x12,0xcd,0x55,0x87,0x5c,0xc0,0x35,0x85,0x99,0x44,0x02,0xa5,0x0b,0x8c,0xe7,0x2c,0x68},
<a name="l00429"></a>00429                 {0x76,0x54,0x32,0x13,0xac,0xfd,0x87,0x50,0xc3,0x8f,0xcd,0x58,0xaa,0xa5,0x7e,0x7a,0x25,0x63,0x26,0xd1},
<a name="l00430"></a>00430                 {0x76,0x54,0x32,0x14,0xe3,0x30,0xf5,0xdd,0x27,0x2b,0x76,0x22,0x7f,0xaa,0x90,0x73,0x6a,0x48,0xdb,0x00},
<a name="l00431"></a>00431                 {0x76,0x54,0x32,0x15,0xfc,0x57,0x00,0x20,0x7c,0x9d,0xf6,0x30,0x6f,0xbd,0x46,0x3e,0xfb,0x8a,0x2c,0x60},
<a name="l00432"></a>00432                 {0x76,0x54,0x32,0x16,0xfb,0x0f,0xd3,0xdf,0x4c,0x4b,0xc3,0x05,0x9d,0x63,0x1e,0xba,0x25,0x2b,0xbe,0x35},
<a name="l00433"></a>00433                 {0x76,0x54,0x32,0x17,0xc6,0xfe,0xe6,0x5f,0xb1,0x35,0x8a,0xf5,0x32,0x7a,0x80,0xbd,0xb8,0x72,0xee,0xae}}};
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         byte digest[XMACC_MD5::DIGESTSIZE];
<a name="l00436"></a>00436         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         cout &lt;&lt; <span class="stringliteral">&quot;\nXMACC/MD5 validation suite running...\n&quot;</span>;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;2; k++)
<a name="l00441"></a>00441         {
<a name="l00442"></a>00442                 XMACC_MD5 mac(keys[k], counters[k]);
<a name="l00443"></a>00443                 cout &lt;&lt; <span class="stringliteral">&quot;\nKEY: &quot;</span>;
<a name="l00444"></a>00444                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;XMACC_MD5::KEYLENGTH;j++)
<a name="l00445"></a>00445                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)keys[k][j];
<a name="l00446"></a>00446                 cout &lt;&lt; <span class="stringliteral">&quot;    COUNTER: 0x&quot;</span> &lt;&lt; hex &lt;&lt; counters[k] &lt;&lt; endl &lt;&lt; endl;
<a name="l00447"></a>00447                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;7;i++)
<a name="l00448"></a>00448                 {
<a name="l00449"></a>00449                         mac.Update((byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00450"></a>00450                         mac.Final(digest);
<a name="l00451"></a>00451                         fail = memcmp(digest, output[k][i], XMACC_MD5::DIGESTSIZE)
<a name="l00452"></a>00452                                  || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));
<a name="l00453"></a>00453                         pass = pass &amp;&amp; !fail;
<a name="l00454"></a>00454                         cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED   &quot;</span> : <span class="stringliteral">&quot;passed   &quot;</span>);
<a name="l00455"></a>00455                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;XMACC_MD5::DIGESTSIZE;j++)
<a name="l00456"></a>00456                                 cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)digest[j];
<a name="l00457"></a>00457                         cout &lt;&lt; <span class="stringliteral">&quot;   \&quot;&quot;</span> &lt;&lt; TestVals[i] &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span> &lt;&lt; endl;
<a name="l00458"></a>00458                 }
<a name="l00459"></a>00459         }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         <span class="keywordflow">return</span> pass;
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 <span class="preprocessor">#endif</span>
<a name="l00464"></a>00464 <span class="preprocessor"></span>
<a name="l00465"></a>00465 <span class="keywordtype">bool</span> ValidateTTMAC()
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467         <span class="keyword">const</span> byte key[TTMAC::KEYLENGTH]={
<a name="l00468"></a>00468                 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,
<a name="l00469"></a>00469                 0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x01,0x23,0x45,0x67};
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="keyword">const</span> <span class="keywordtype">char</span> *TestVals[8]={
<a name="l00472"></a>00472                 <span class="stringliteral">&quot;&quot;</span>,
<a name="l00473"></a>00473                 <span class="stringliteral">&quot;a&quot;</span>,
<a name="l00474"></a>00474                 <span class="stringliteral">&quot;abc&quot;</span>,
<a name="l00475"></a>00475                 <span class="stringliteral">&quot;message digest&quot;</span>,
<a name="l00476"></a>00476                 <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>,
<a name="l00477"></a>00477                 <span class="stringliteral">&quot;abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq&quot;</span>,
<a name="l00478"></a>00478                 <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>,
<a name="l00479"></a>00479                 <span class="stringliteral">&quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;</span>};
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         <span class="keyword">const</span> byte output[8][TTMAC::DIGESTSIZE]={
<a name="l00482"></a>00482                 {0x2d,0xec,0x8e,0xd4,0xa0,0xfd,0x71,0x2e,0xd9,0xfb,0xf2,0xab,0x46,0x6e,0xc2,0xdf,0x21,0x21,0x5e,0x4a},
<a name="l00483"></a>00483                 {0x58,0x93,0xe3,0xe6,0xe3,0x06,0x70,0x4d,0xd7,0x7a,0xd6,0xe6,0xed,0x43,0x2c,0xde,0x32,0x1a,0x77,0x56},
<a name="l00484"></a>00484                 {0x70,0xbf,0xd1,0x02,0x97,0x97,0xa5,0xc1,0x6d,0xa5,0xb5,0x57,0xa1,0xf0,0xb2,0x77,0x9b,0x78,0x49,0x7e},
<a name="l00485"></a>00485                 {0x82,0x89,0xf4,0xf1,0x9f,0xfe,0x4f,0x2a,0xf7,0x37,0xde,0x4b,0xd7,0x1c,0x82,0x9d,0x93,0xa9,0x72,0xfa},
<a name="l00486"></a>00486                 {0x21,0x86,0xca,0x09,0xc5,0x53,0x31,0x98,0xb7,0x37,0x1f,0x24,0x52,0x73,0x50,0x4c,0xa9,0x2b,0xae,0x60},
<a name="l00487"></a>00487                 {0x8a,0x7b,0xf7,0x7a,0xef,0x62,0xa2,0x57,0x84,0x97,0xa2,0x7c,0x0d,0x65,0x18,0xa4,0x29,0xe7,0xc1,0x4d},
<a name="l00488"></a>00488                 {0x54,0xba,0xc3,0x92,0xa8,0x86,0x80,0x6d,0x16,0x95,0x56,0xfc,0xbb,0x67,0x89,0xb5,0x4f,0xb3,0x64,0xfb},
<a name="l00489"></a>00489                 {0x0c,0xed,0x2c,0x9f,0x8f,0x0d,0x9d,0x03,0x98,0x1a,0xb5,0xc8,0x18,0x4b,0xac,0x43,0xdd,0x54,0xc4,0x84}};
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         byte digest[TTMAC::DIGESTSIZE];
<a name="l00492"></a>00492         <span class="keywordtype">bool</span> pass=<span class="keyword">true</span>, fail;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         cout &lt;&lt; <span class="stringliteral">&quot;\nTwo-Track-MAC validation suite running...\n&quot;</span>;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         <a class="code" href="class_t_t_m_a_c.html" title="Two-Track-MAC">TTMAC</a> mac(key, <span class="keyword">sizeof</span>(key));
<a name="l00497"></a>00497         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;<span class="keyword">sizeof</span>(TestVals)/<span class="keyword">sizeof</span>(TestVals[0]); k++)
<a name="l00498"></a>00498         {
<a name="l00499"></a>00499                 mac.Update((byte *)TestVals[k], strlen(TestVals[k]));
<a name="l00500"></a>00500                 mac.Final(digest);
<a name="l00501"></a>00501                 fail = memcmp(digest, output[k], TTMAC::DIGESTSIZE)
<a name="l00502"></a>00502                         || !mac.VerifyDigest(output[k], (byte *)TestVals[k], strlen(TestVals[k]));
<a name="l00503"></a>00503                 pass = pass &amp;&amp; !fail;
<a name="l00504"></a>00504                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED   &quot;</span> : <span class="stringliteral">&quot;passed   &quot;</span>);
<a name="l00505"></a>00505                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;TTMAC::DIGESTSIZE;j++)
<a name="l00506"></a>00506                         cout &lt;&lt; setw(2) &lt;&lt; setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; hex &lt;&lt; (int)digest[j];
<a name="l00507"></a>00507                 cout &lt;&lt; <span class="stringliteral">&quot;   \&quot;&quot;</span> &lt;&lt; TestVals[k] &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span> &lt;&lt; endl;
<a name="l00508"></a>00508         }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a><a class="code" href="struct_p_b_k_d_f___test_tuple.html">00513</a> <span class="keyword">struct </span><a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a>
<a name="l00514"></a>00514 {
<a name="l00515"></a>00515         byte purpose;
<a name="l00516"></a>00516         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iterations;
<a name="l00517"></a>00517         <span class="keyword">const</span> <span class="keywordtype">char</span> *hexPassword, *hexSalt, *hexDerivedKey;
<a name="l00518"></a>00518 };
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="keywordtype">bool</span> TestPBKDF(<a class="code" href="class_password_based_key_derivation_function.html" title="abstract base class for password based key derivation function">PasswordBasedKeyDerivationFunction</a> &amp;pbkdf, <span class="keyword">const</span> <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> *testSet, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> testSetSize)
<a name="l00521"></a>00521 {
<a name="l00522"></a>00522         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;testSetSize; i++)
<a name="l00525"></a>00525         {
<a name="l00526"></a>00526                 <span class="keyword">const</span> <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> &amp;tuple = testSet[i];
<a name="l00527"></a>00527 
<a name="l00528"></a>00528                 <span class="keywordtype">string</span> password, salt, derivedKey;
<a name="l00529"></a>00529                 <a class="code" href="class_string_source.html" title="string-based implementation of Source interface">StringSource</a>(tuple.hexPassword, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>(<span class="keyword">new</span> <a class="code" href="class_string_sink_template.html" title="Append input to a string object.">StringSink</a>(password)));
<a name="l00530"></a>00530                 <a class="code" href="class_string_source.html" title="string-based implementation of Source interface">StringSource</a>(tuple.hexSalt, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>(<span class="keyword">new</span> <a class="code" href="class_string_sink_template.html" title="Append input to a string object.">StringSink</a>(salt)));
<a name="l00531"></a>00531                 <a class="code" href="class_string_source.html" title="string-based implementation of Source interface">StringSource</a>(tuple.hexDerivedKey, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_hex_decoder.html" title="Decode base 16 data back to bytes.">HexDecoder</a>(<span class="keyword">new</span> <a class="code" href="class_string_sink_template.html" title="Append input to a string object.">StringSink</a>(derivedKey)));
<a name="l00532"></a>00532 
<a name="l00533"></a>00533                 <a class="code" href="class_sec_block.html">SecByteBlock</a> derived(derivedKey.size());
<a name="l00534"></a>00534                 pbkdf.<a class="code" href="class_password_based_key_derivation_function.html#aeaff60e52adddbaf6abd9ff2b64f5356" title="derive key from password">DeriveKey</a>(derived, derived.size(), tuple.purpose, (byte *)password.data(), password.size(), (byte *)salt.data(), salt.size(), tuple.iterations);
<a name="l00535"></a>00535                 <span class="keywordtype">bool</span> fail = memcmp(derived, derivedKey.data(), derived.size()) != 0;
<a name="l00536"></a>00536                 pass = pass &amp;&amp; !fail;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538                 <a class="code" href="class_hex_encoder.html" title="Converts given data to base 16.">HexEncoder</a> enc(<span class="keyword">new</span> <a class="code" href="class_file_sink.html" title="file-based implementation of Sink interface">FileSink</a>(cout));
<a name="l00539"></a>00539                 cout &lt;&lt; (fail ? <span class="stringliteral">&quot;FAILED   &quot;</span> : <span class="stringliteral">&quot;passed   &quot;</span>);
<a name="l00540"></a>00540                 enc.Put(tuple.purpose);
<a name="l00541"></a>00541                 cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; tuple.iterations;
<a name="l00542"></a>00542                 cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; tuple.hexPassword &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; tuple.hexSalt &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00543"></a>00543                 enc.Put(derived, derived.size());
<a name="l00544"></a>00544                 cout &lt;&lt; endl;
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547         <span class="keywordflow">return</span> pass;
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="keywordtype">bool</span> ValidatePBKDF()
<a name="l00551"></a>00551 {
<a name="l00552"></a>00552         <span class="keywordtype">bool</span> pass = <span class="keyword">true</span>;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         {
<a name="l00555"></a>00555         <span class="comment">// from OpenSSL PKCS#12 Program FAQ v1.77, at http://www.drh-consultancy.demon.co.uk/test.txt</span>
<a name="l00556"></a>00556         <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> testSet[] = 
<a name="l00557"></a>00557         {
<a name="l00558"></a>00558                 {1, 1, <span class="stringliteral">&quot;0073006D006500670000&quot;</span>, <span class="stringliteral">&quot;0A58CF64530D823F&quot;</span>, <span class="stringliteral">&quot;8AAAE6297B6CB04642AB5B077851284EB7128F1A2A7FBCA3&quot;</span>},
<a name="l00559"></a>00559                 {2, 1, <span class="stringliteral">&quot;0073006D006500670000&quot;</span>, <span class="stringliteral">&quot;0A58CF64530D823F&quot;</span>, <span class="stringliteral">&quot;79993DFE048D3B76&quot;</span>},
<a name="l00560"></a>00560                 {1, 1, <span class="stringliteral">&quot;0073006D006500670000&quot;</span>, <span class="stringliteral">&quot;642B99AB44FB4B1F&quot;</span>, <span class="stringliteral">&quot;F3A95FEC48D7711E985CFE67908C5AB79FA3D7C5CAA5D966&quot;</span>},
<a name="l00561"></a>00561                 {2, 1, <span class="stringliteral">&quot;0073006D006500670000&quot;</span>, <span class="stringliteral">&quot;642B99AB44FB4B1F&quot;</span>, <span class="stringliteral">&quot;C0A38D64A79BEA1D&quot;</span>},
<a name="l00562"></a>00562                 {3, 1, <span class="stringliteral">&quot;0073006D006500670000&quot;</span>, <span class="stringliteral">&quot;3D83C0E4546AC140&quot;</span>, <span class="stringliteral">&quot;8D967D88F6CAA9D714800AB3D48051D63F73A312&quot;</span>},
<a name="l00563"></a>00563                 {1, 1000, <span class="stringliteral">&quot;007100750065006500670000&quot;</span>, <span class="stringliteral">&quot;05DEC959ACFF72F7&quot;</span>, <span class="stringliteral">&quot;ED2034E36328830FF09DF1E1A07DD357185DAC0D4F9EB3D4&quot;</span>},
<a name="l00564"></a>00564                 {2, 1000, <span class="stringliteral">&quot;007100750065006500670000&quot;</span>, <span class="stringliteral">&quot;05DEC959ACFF72F7&quot;</span>, <span class="stringliteral">&quot;11DEDAD7758D4860&quot;</span>},
<a name="l00565"></a>00565                 {1, 1000, <span class="stringliteral">&quot;007100750065006500670000&quot;</span>, <span class="stringliteral">&quot;1682C0FC5B3F7EC5&quot;</span>, <span class="stringliteral">&quot;483DD6E919D7DE2E8E648BA8F862F3FBFBDC2BCB2C02957F&quot;</span>},
<a name="l00566"></a>00566                 {2, 1000, <span class="stringliteral">&quot;007100750065006500670000&quot;</span>, <span class="stringliteral">&quot;1682C0FC5B3F7EC5&quot;</span>, <span class="stringliteral">&quot;9D461D1B00355C50&quot;</span>},
<a name="l00567"></a>00567                 {3, 1000, <span class="stringliteral">&quot;007100750065006500670000&quot;</span>, <span class="stringliteral">&quot;263216FCC2FAB31C&quot;</span>, <span class="stringliteral">&quot;5EC4C7A80DF652294C3925B6489A7AB857C83476&quot;</span>}
<a name="l00568"></a>00568         };
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         <a class="code" href="class_p_k_c_s12___p_b_k_d_f.html" title="PBKDF from PKCS #12, appendix B, T should be a HashTransformation class.">PKCS12_PBKDF&lt;SHA1&gt;</a> pbkdf;
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         cout &lt;&lt; <span class="stringliteral">&quot;\nPKCS #12 PBKDF validation suite running...\n\n&quot;</span>;
<a name="l00573"></a>00573         pass = TestPBKDF(pbkdf, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0])) &amp;&amp; pass;
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576         {
<a name="l00577"></a>00577         <span class="comment">// from draft-ietf-smime-password-03.txt, at http://www.imc.org/draft-ietf-smime-password</span>
<a name="l00578"></a>00578         <a class="code" href="struct_p_b_k_d_f___test_tuple.html">PBKDF_TestTuple</a> testSet[] = 
<a name="l00579"></a>00579         {
<a name="l00580"></a>00580                 {0, 5, <span class="stringliteral">&quot;70617373776f7264&quot;</span>, <span class="stringliteral">&quot;1234567878563412&quot;</span>, <span class="stringliteral">&quot;D1DAA78615F287E6&quot;</span>},
<a name="l00581"></a>00581                 {0, 500, <span class="stringliteral">&quot;416C6C206E2D656E746974696573206D75737420636F6D6D756E69636174652077697468206F74686572206E2d656E74697469657320766961206E2D3120656E746974656568656568656573&quot;</span>, <span class="stringliteral">&quot;1234567878563412&quot;</span>,<span class="stringliteral">&quot;6A8970BF68C92CAEA84A8DF28510858607126380CC47AB2D&quot;</span>}
<a name="l00582"></a>00582         };
<a name="l00583"></a>00583 
<a name="l00584"></a>00584         <a class="code" href="class_p_k_c_s5___p_b_k_d_f2___h_m_a_c.html" title="PBKDF2 from PKCS #5, T should be a HashTransformation class.">PKCS5_PBKDF2_HMAC&lt;SHA1&gt;</a> pbkdf;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586         cout &lt;&lt; <span class="stringliteral">&quot;\nPKCS #5 PBKDF2 validation suite running...\n\n&quot;</span>;
<a name="l00587"></a>00587         pass = TestPBKDF(pbkdf, testSet, <span class="keyword">sizeof</span>(testSet)/<span class="keyword">sizeof</span>(testSet[0])) &amp;&amp; pass;
<a name="l00588"></a>00588         }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         <span class="keywordflow">return</span> pass;
<a name="l00591"></a>00591 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 9 2010 15:56:38 for Crypto++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
